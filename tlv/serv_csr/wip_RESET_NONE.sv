//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro
//_\source wip.tlv 113

//_\SV
`default_nettype none
module serv_csr
  #(
    parameter RESET_STRATEGY = "MINI",
    parameter W = 1,
    parameter B = W-1
  )
  (
   input wire 	    i_clk,
   input wire 	    i_rst,
   //State
   input wire 	    i_trig_irq,
   input wire 	    i_en,
   input wire 	    i_cnt0to3,
   input wire 	    i_cnt3,
   input wire 	    i_cnt7,
   input wire 	    i_cnt11,
   input wire 	    i_cnt12,
   input wire 	    i_cnt_done,
   input wire 	    i_mem_op,
   input wire 	    i_mtip,
   input wire 	    i_trap,
   output reg 	    o_new_irq,
   //Control
   input wire 	    i_e_op,
   input wire 	    i_ebreak,
   input wire 	    i_mem_cmd,
   input wire 	    i_mstatus_en,
   input wire 	    i_mie_en,
   input wire 	    i_mcause_en,
   input wire [1:0] i_csr_source,
   input wire 	    i_mret,
   input wire 	    i_csr_d_sel,
   //Data
   input wire 	[B:0]    i_rf_csr_out,
   output wire 	[B:0]    o_csr_in,
   input wire 	[B:0]    i_csr_imm,
   input wire 	[B:0]    i_rs1,
   output wire 	[B:0]    o_q);

// ---------- Generated Code Inlined Here (before 1st \TLV) ----------
// Generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro from Redwood EDA, LLC.
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)





//
// Signals declared top-level.
//

// For |default$csr_data.
logic [B:0] DEFAULT_csr_data_a0;

// For |default$csr_in.
logic [B:0] DEFAULT_csr_in_a0;

// For |default$csr_out.
logic [B:0] DEFAULT_csr_out_a0;

// For |default$i_cnt0to3.
logic DEFAULT_i_cnt0to3_a0;

// For |default$i_cnt11.
logic DEFAULT_i_cnt11_a0;

// For |default$i_cnt12.
logic DEFAULT_i_cnt12_a0;

// For |default$i_cnt3.
logic DEFAULT_i_cnt3_a0;

// For |default$i_cnt7.
logic DEFAULT_i_cnt7_a0;

// For |default$i_cnt_done.
logic DEFAULT_i_cnt_done_a0;

// For |default$i_csr_d_sel.
logic DEFAULT_i_csr_d_sel_a0;

// For |default$i_csr_imm.
logic [B:0] DEFAULT_i_csr_imm_a0;

// For |default$i_csr_source.
logic [1:0] DEFAULT_i_csr_source_a0;

// For |default$i_e_op.
logic DEFAULT_i_e_op_a0;

// For |default$i_ebreak.
logic DEFAULT_i_ebreak_a0;

// For |default$i_en.
logic DEFAULT_i_en_a0;

// For |default$i_mcause_en.
logic DEFAULT_i_mcause_en_a0;

// For |default$i_mem_cmd.
logic DEFAULT_i_mem_cmd_a0;

// For |default$i_mem_op.
logic DEFAULT_i_mem_op_a0;

// For |default$i_mie_en.
logic DEFAULT_i_mie_en_a0;

// For |default$i_mret.
logic DEFAULT_i_mret_a0;

// For |default$i_mstatus_en.
logic DEFAULT_i_mstatus_en_a0;

// For |default$i_mtip.
logic DEFAULT_i_mtip_a0;

// For |default$i_rf_csr_out.
logic [B:0] DEFAULT_i_rf_csr_out_a0;

// For |default$i_rs1.
logic [B:0] DEFAULT_i_rs1_a0;

// For |default$i_rst.
logic DEFAULT_i_rst_a0;

// For |default$i_trap.
logic DEFAULT_i_trap_a0;

// For |default$i_trig_irq.
logic DEFAULT_i_trig_irq_a0;

// For |default$mcause.
logic [B:0] DEFAULT_mcause_a0;

// For |default$mcause31.
logic DEFAULT_mcause31_n1,
      DEFAULT_mcause31_a0;

// For |default$mcause3dot0.
logic [3:0] DEFAULT_mcause3dot0_a0;

// For |default$mcause3dot0_0.
logic DEFAULT_mcause3dot0_0_n1,
      DEFAULT_mcause3dot0_0_a0;

// For |default$mcause3dot0_1.
logic DEFAULT_mcause3dot0_1_n1,
      DEFAULT_mcause3dot0_1_a0;

// For |default$mcause3dot0_2.
logic DEFAULT_mcause3dot0_2_n1,
      DEFAULT_mcause3dot0_2_a0;

// For |default$mcause3dot0_3.
logic DEFAULT_mcause3dot0_3_n1,
      DEFAULT_mcause3dot0_3_a0;

// For |default$mcause_update_en.
logic DEFAULT_mcause_update_en_a0;

// For |default$mie_mtie.
logic DEFAULT_mie_mtie_n1,
      DEFAULT_mie_mtie_a0;

// For |default$mstatus.
logic [B:0] DEFAULT_mstatus_a0;

// For |default$mstatus_mie.
logic DEFAULT_mstatus_mie_n1,
      DEFAULT_mstatus_mie_a0;

// For |default$mstatus_mpie.
logic DEFAULT_mstatus_mpie_n1,
      DEFAULT_mstatus_mpie_a0;

// For |default$o_csr_in.
logic [B:0] DEFAULT_o_csr_in_a0;

// For |default$o_new_irq_tlv.
logic DEFAULT_o_new_irq_tlv_n1,
      DEFAULT_o_new_irq_tlv_a0;

// For |default$o_q.
logic [B:0] DEFAULT_o_q_a0;

// For |default$timer_irq.
logic DEFAULT_timer_irq_a0;

// For |default$timer_irq_r.
logic DEFAULT_timer_irq_r_n1,
      DEFAULT_timer_irq_r_a0;




   //
   // Scope: |default
   //

      // Staging of $mcause31.
      always_ff @(posedge clk) DEFAULT_mcause31_a0 <= DEFAULT_mcause31_n1;

      // Staging of $mcause3dot0_0.
      always_ff @(posedge clk) DEFAULT_mcause3dot0_0_a0 <= DEFAULT_mcause3dot0_0_n1;

      // Staging of $mcause3dot0_1.
      always_ff @(posedge clk) DEFAULT_mcause3dot0_1_a0 <= DEFAULT_mcause3dot0_1_n1;

      // Staging of $mcause3dot0_2.
      always_ff @(posedge clk) DEFAULT_mcause3dot0_2_a0 <= DEFAULT_mcause3dot0_2_n1;

      // Staging of $mcause3dot0_3.
      always_ff @(posedge clk) DEFAULT_mcause3dot0_3_a0 <= DEFAULT_mcause3dot0_3_n1;

      // Staging of $mie_mtie.
      always_ff @(posedge clk) DEFAULT_mie_mtie_a0 <= DEFAULT_mie_mtie_n1;

      // Staging of $mstatus_mie.
      always_ff @(posedge clk) DEFAULT_mstatus_mie_a0 <= DEFAULT_mstatus_mie_n1;

      // Staging of $mstatus_mpie.
      always_ff @(posedge clk) DEFAULT_mstatus_mpie_a0 <= DEFAULT_mstatus_mpie_n1;

      // Staging of $o_new_irq_tlv.
      always_ff @(posedge clk) DEFAULT_o_new_irq_tlv_a0 <= DEFAULT_o_new_irq_tlv_n1;

      // Staging of $timer_irq_r.
      always_ff @(posedge clk) DEFAULT_timer_irq_r_a0 <= DEFAULT_timer_irq_r_n1;



// ---------- Generated Code Ends ----------
//_\TLV
   // Connect Verilog inputs to pipesignals
   //_|default
      //_@0
         assign DEFAULT_i_rst_a0 = i_rst;
         assign DEFAULT_i_trig_irq_a0 = i_trig_irq;
         assign DEFAULT_i_en_a0 = i_en;
         assign DEFAULT_i_cnt0to3_a0 = i_cnt0to3;
         assign DEFAULT_i_cnt3_a0 = i_cnt3;
         assign DEFAULT_i_cnt7_a0 = i_cnt7;
         assign DEFAULT_i_cnt11_a0 = i_cnt11;
         assign DEFAULT_i_cnt12_a0 = i_cnt12;
         assign DEFAULT_i_cnt_done_a0 = i_cnt_done;
         assign DEFAULT_i_mem_op_a0 = i_mem_op;
         assign DEFAULT_i_mtip_a0 = i_mtip;
         assign DEFAULT_i_trap_a0 = i_trap;
         assign DEFAULT_i_e_op_a0 = i_e_op;
         assign DEFAULT_i_ebreak_a0 = i_ebreak;
         assign DEFAULT_i_mem_cmd_a0 = i_mem_cmd;
         assign DEFAULT_i_mstatus_en_a0 = i_mstatus_en;
         assign DEFAULT_i_mie_en_a0 = i_mie_en;
         assign DEFAULT_i_mcause_en_a0 = i_mcause_en;
         assign DEFAULT_i_csr_source_a0[1:0] = i_csr_source;
         assign DEFAULT_i_mret_a0 = i_mret;
         assign DEFAULT_i_csr_d_sel_a0 = i_csr_d_sel;
         assign DEFAULT_i_rf_csr_out_a0[B:0] = i_rf_csr_out;
         assign DEFAULT_i_csr_imm_a0[B:0] = i_csr_imm;
         assign DEFAULT_i_rs1_a0[B:0] = i_rs1;

   // Clock assignment for TL-Verilog
   /*SV_plus*/
      wire clk = i_clk;

   // Instantiate the serv_csr macro
   //_\source wip.tlv 6   // Instantiated from wip.tlv, 190 as: m5+serv_csr(/top)
      // CSR Source Constants
      /*SV_plus*/
         localparam [1:0]
           CSR_SOURCE_CSR = 2'b00,
           CSR_SOURCE_EXT = 2'b01,
           CSR_SOURCE_SET = 2'b10,
           CSR_SOURCE_CLR = 2'b11;
   
      //_|default
         //_@0
            // === Combinational Logic ===
   
            // CSR data input selection
            assign DEFAULT_csr_data_a0[B:0] = DEFAULT_i_csr_d_sel_a0 ? DEFAULT_i_csr_imm_a0 : DEFAULT_i_rs1_a0;
   
            // CSR input processing based on operation type
            assign DEFAULT_csr_in_a0[B:0] = (DEFAULT_i_csr_source_a0 == CSR_SOURCE_EXT) ? DEFAULT_csr_data_a0 :
                           (DEFAULT_i_csr_source_a0 == CSR_SOURCE_SET) ? DEFAULT_csr_out_a0 | DEFAULT_csr_data_a0 :
                           (DEFAULT_i_csr_source_a0 == CSR_SOURCE_CLR) ? DEFAULT_csr_out_a0 & ~ DEFAULT_csr_data_a0 :
                           (DEFAULT_i_csr_source_a0 == CSR_SOURCE_CSR) ? DEFAULT_csr_out_a0 :
                           {W{1'bx}};
   
            // MSTATUS register readout (parameterized for different widths)
            assign DEFAULT_mstatus_a0[B:0] = (W == 1) ? ((DEFAULT_mstatus_mie_a0 & DEFAULT_i_cnt3_a0) | (DEFAULT_i_cnt11_a0 | DEFAULT_i_cnt12_a0)) :
                            (W == 4) ? {DEFAULT_i_cnt11_a0 | (DEFAULT_mstatus_mie_a0 & DEFAULT_i_cnt3_a0), 2'b00, DEFAULT_i_cnt12_a0} :
                            {W{1'b0}};
   
            // Timer interrupt signal
            assign DEFAULT_timer_irq_a0 = DEFAULT_i_mtip_a0 & DEFAULT_mstatus_mie_a0 & DEFAULT_mie_mtie_a0;
   
            // MCAUSE register readout
            assign DEFAULT_mcause_a0[B:0] = DEFAULT_i_cnt0to3_a0 ? DEFAULT_mcause3dot0_a0[B:0] :    //[3:0]
                           DEFAULT_i_cnt_done_a0 ? {DEFAULT_mcause31_a0, {B{1'b0}}} : //[31]
                           {W{1'b0}};
   
            // CSR output multiplexing
            assign DEFAULT_csr_out_a0[B:0] = ({W{DEFAULT_i_mstatus_en_a0 & DEFAULT_i_en_a0}} & DEFAULT_mstatus_a0) |
                            DEFAULT_i_rf_csr_out_a0 |
                            ({W{DEFAULT_i_mcause_en_a0 & DEFAULT_i_en_a0}} & DEFAULT_mcause_a0);
   
            // Module outputs
            assign DEFAULT_o_q_a0[B:0] = DEFAULT_csr_out_a0;
            assign DEFAULT_o_csr_in_a0[B:0] = DEFAULT_csr_in_a0;
   
            // Combine individual mcause bits into array format
            assign DEFAULT_mcause3dot0_a0[3:0] = {DEFAULT_mcause3dot0_3_a0, DEFAULT_mcause3dot0_2_a0, DEFAULT_mcause3dot0_1_a0, DEFAULT_mcause3dot0_0_a0};
   
            // === State Register Updates ===
   
            // Timer interrupt tracking
            assign DEFAULT_timer_irq_r_n1 = DEFAULT_i_trig_irq_a0 ? DEFAULT_timer_irq_a0 : DEFAULT_timer_irq_r_a0;
            assign DEFAULT_o_new_irq_tlv_n1 = (DEFAULT_i_rst_a0 & (RESET_STRATEGY != "NONE")) ? 1'b0 :
                                DEFAULT_i_trig_irq_a0 ? (DEFAULT_timer_irq_a0 & !DEFAULT_timer_irq_r_a0) : DEFAULT_o_new_irq_tlv_a0;
   
            // MIE register update
            assign DEFAULT_mie_mtie_n1 = (DEFAULT_i_rst_a0 & (RESET_STRATEGY != "NONE")) ? 1'b0 :
                           (DEFAULT_i_mie_en_a0 & DEFAULT_i_cnt7_a0) ? DEFAULT_csr_in_a0[B] : DEFAULT_mie_mtie_a0;
   
            /*
             The mie bit in mstatus gets updated under three conditions
   
             When a trap is taken, the bit is cleared
             During an mret instruction, the bit is restored from mpie
             During a mstatus CSR access instruction it's assigned when
              bit 3 gets updated
   
             These conditions are all mutually exclusive
             */
            assign DEFAULT_mstatus_mie_n1 = ((DEFAULT_i_trap_a0 & DEFAULT_i_cnt_done_a0) | DEFAULT_i_mstatus_en_a0 & DEFAULT_i_cnt3_a0 & DEFAULT_i_en_a0 | DEFAULT_i_mret_a0) ?
                              (!DEFAULT_i_trap_a0 & (DEFAULT_i_mret_a0 ? DEFAULT_mstatus_mpie_a0 : DEFAULT_csr_in_a0[B])) : DEFAULT_mstatus_mie_a0;
   
            /*
             Note: To save resources mstatus_mpie (mstatus bit 7) is not
             readable or writable from sw
             */
            assign DEFAULT_mstatus_mpie_n1 = (DEFAULT_i_trap_a0 & DEFAULT_i_cnt_done_a0) ? DEFAULT_mstatus_mie_a0 : DEFAULT_mstatus_mpie_a0;
   
            /*
             The four lowest bits in mcause hold the exception code
   
             These bits get updated under three conditions
   
             During an mcause CSR access function, they are assigned when
             bits 0 to 3 gets updated
   
             During an external interrupt the exception code is set to
             7, since SERV only support timer interrupts
   
             During an exception, the exception code is assigned to indicate
             if it was caused by an ebreak instruction (3),
             ecall instruction (11), misaligned load (4), misaligned store (6)
             or misaligned jump (0)
   
             The expressions below are derived from the following truth table
             irq  => 0111 (timer=7)
             e_op => x011 (ebreak=3, ecall=11)
             mem  => 01x0 (store=6, load=4)
             ctrl => 0000 (jump=0)
             */
            assign DEFAULT_mcause_update_en_a0 = DEFAULT_i_mcause_en_a0 & DEFAULT_i_en_a0 & DEFAULT_i_cnt0to3_a0 | (DEFAULT_i_trap_a0 & DEFAULT_i_cnt_done_a0);
            assign DEFAULT_mcause3dot0_3_n1 = DEFAULT_mcause_update_en_a0 ? ((DEFAULT_i_e_op_a0 & !DEFAULT_i_ebreak_a0) | (!DEFAULT_i_trap_a0 & DEFAULT_csr_in_a0[B])) : DEFAULT_mcause3dot0_3_a0;
            assign DEFAULT_mcause3dot0_2_n1 = DEFAULT_mcause_update_en_a0 ? (DEFAULT_o_new_irq_tlv_a0 | DEFAULT_i_mem_op_a0 | (!DEFAULT_i_trap_a0 & ((W == 1) ? DEFAULT_mcause3dot0_3_a0 : DEFAULT_csr_in_a0[(W == 1) ? 0 : 2]))) : DEFAULT_mcause3dot0_2_a0;
            assign DEFAULT_mcause3dot0_1_n1 = DEFAULT_mcause_update_en_a0 ? (DEFAULT_o_new_irq_tlv_a0 | DEFAULT_i_e_op_a0 | (DEFAULT_i_mem_op_a0 & DEFAULT_i_mem_cmd_a0) | (!DEFAULT_i_trap_a0 & ((W == 1) ? DEFAULT_mcause3dot0_2_a0 : DEFAULT_csr_in_a0[(W == 1) ? 0 : 1]))) : DEFAULT_mcause3dot0_1_a0;
            assign DEFAULT_mcause3dot0_0_n1 = DEFAULT_mcause_update_en_a0 ? (DEFAULT_o_new_irq_tlv_a0 | DEFAULT_i_e_op_a0 | (!DEFAULT_i_trap_a0 & ((W == 1) ? DEFAULT_mcause3dot0_1_a0 : DEFAULT_csr_in_a0[0]))) : DEFAULT_mcause3dot0_0_a0;
   
            assign DEFAULT_mcause31_n1 = (DEFAULT_i_mcause_en_a0 & DEFAULT_i_cnt_done_a0 | DEFAULT_i_trap_a0) ?
                           (DEFAULT_i_trap_a0 ? DEFAULT_o_new_irq_tlv_a0 : DEFAULT_csr_in_a0[B]) : DEFAULT_mcause31_a0;
   //_\end_source

   // Connect pipesignals to Verilog outputs
   //_|default
      //_@0
         assign o_new_irq = DEFAULT_o_new_irq_tlv_a0;
         assign o_csr_in = DEFAULT_o_csr_in_a0;
         assign o_q = DEFAULT_o_q_a0;

//_\SV
endmodule


// Undefine macros defined by SandPiper.
`undef BOGUS_USE
