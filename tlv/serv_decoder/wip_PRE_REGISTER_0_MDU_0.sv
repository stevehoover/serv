//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro
//_\source wip.tlv 3
//_\SV
`default_nettype none
module serv_decode
  #(parameter [0:0] PRE_REGISTER = 1,
    parameter [0:0] MDU = 0)
  (
   input wire        clk,
   //Input
   input wire [31:2] i_wb_rdt,
   input wire        i_wb_en,
   //To state
   output reg       o_sh_right,
   output reg       o_bne_or_bge,
   output reg       o_cond_branch,
   output reg       o_e_op,
   output reg       o_ebreak,
   output reg       o_branch_op,
   output reg       o_shift_op,
   output reg       o_rd_op,
   output reg       o_two_stage_op,
   output reg       o_dbus_en,
   //MDU
   output reg       o_mdu_op,
   //Extension
   output reg [2:0] o_ext_funct3,
   //To bufreg
   output reg       o_bufreg_rs1_en,
   output reg       o_bufreg_imm_en,
   output reg       o_bufreg_clr_lsb,
   output reg       o_bufreg_sh_signed,
   //To ctrl
   output reg       o_ctrl_jal_or_jalr,
   output reg       o_ctrl_utype,
   output reg       o_ctrl_pc_rel,
   output reg       o_ctrl_mret,
   //To alu
   output reg       o_alu_sub,
   output reg [1:0] o_alu_bool_op,
   output reg       o_alu_cmp_eq,
   output reg       o_alu_cmp_sig,
   output reg [2:0] o_alu_rd_sel,
   //To mem IF
   output reg       o_mem_signed,
   output reg       o_mem_word,
   output reg       o_mem_half,
   output reg       o_mem_cmd,
   //To CSR
   output reg       o_csr_en,
   output reg [1:0] o_csr_addr,
   output reg       o_csr_mstatus_en,
   output reg       o_csr_mie_en,
   output reg       o_csr_mcause_en,
   output reg [1:0] o_csr_source,
   output reg       o_csr_d_sel,
   output reg       o_csr_imm_en,
   output reg       o_mtval_pc,
   //To top
   output reg [3:0] o_immdec_ctrl,
   output reg [3:0] o_immdec_en,
   output reg       o_op_b_source,
   //To RF IF
   output reg       o_rd_mem_en,
   output reg       o_rd_csr_en,
   output reg       o_rd_alu_en);
// ---------- Generated Code Inlined Here (before 1st \TLV) ----------
// Generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro from Redwood EDA, LLC.
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)





//
// Signals declared top-level.
//

// For |default$co_alu_bool_op.
logic [1:0] DEFAULT_co_alu_bool_op_a0;

// For |default$co_alu_cmp_eq.
logic DEFAULT_co_alu_cmp_eq_a0;

// For |default$co_alu_cmp_sig.
logic DEFAULT_co_alu_cmp_sig_a0;

// For |default$co_alu_rd_sel.
logic [2:0] DEFAULT_co_alu_rd_sel_a0;

// For |default$co_alu_sub.
logic DEFAULT_co_alu_sub_a0;

// For |default$co_bne_or_bge.
logic DEFAULT_co_bne_or_bge_a0;

// For |default$co_branch_op.
logic DEFAULT_co_branch_op_a0;

// For |default$co_bufreg_clr_lsb.
logic DEFAULT_co_bufreg_clr_lsb_a0;

// For |default$co_bufreg_imm_en.
logic DEFAULT_co_bufreg_imm_en_a0;

// For |default$co_bufreg_rs1_en.
logic DEFAULT_co_bufreg_rs1_en_a0;

// For |default$co_bufreg_sh_signed.
logic DEFAULT_co_bufreg_sh_signed_a0;

// For |default$co_cond_branch.
logic DEFAULT_co_cond_branch_a0;

// For |default$co_csr_addr.
logic [1:0] DEFAULT_co_csr_addr_a0;

// For |default$co_csr_d_sel.
logic DEFAULT_co_csr_d_sel_a0;

// For |default$co_csr_en.
logic DEFAULT_co_csr_en_a0;

// For |default$co_csr_imm_en.
logic DEFAULT_co_csr_imm_en_a0;

// For |default$co_csr_mcause_en.
logic DEFAULT_co_csr_mcause_en_a0;

// For |default$co_csr_mie_en.
logic DEFAULT_co_csr_mie_en_a0;

// For |default$co_csr_mstatus_en.
logic DEFAULT_co_csr_mstatus_en_a0;

// For |default$co_csr_source.
logic [1:0] DEFAULT_co_csr_source_a0;

// For |default$co_ctrl_jal_or_jalr.
logic DEFAULT_co_ctrl_jal_or_jalr_a0;

// For |default$co_ctrl_mret.
logic DEFAULT_co_ctrl_mret_a0;

// For |default$co_ctrl_pc_rel.
logic DEFAULT_co_ctrl_pc_rel_a0;

// For |default$co_ctrl_utype.
logic DEFAULT_co_ctrl_utype_a0;

// For |default$co_dbus_en.
logic DEFAULT_co_dbus_en_a0;

// For |default$co_e_op.
logic DEFAULT_co_e_op_a0;

// For |default$co_ebreak.
logic DEFAULT_co_ebreak_a0;

// For |default$co_ext_funct3.
logic [2:0] DEFAULT_co_ext_funct3_a0;

// For |default$co_immdec_ctrl.
logic [3:0] DEFAULT_co_immdec_ctrl_a0;

// For |default$co_immdec_en.
logic [3:0] DEFAULT_co_immdec_en_a0;

// For |default$co_mdu_op.
logic DEFAULT_co_mdu_op_a0;

// For |default$co_mem_cmd.
logic DEFAULT_co_mem_cmd_a0;

// For |default$co_mem_half.
logic DEFAULT_co_mem_half_a0;

// For |default$co_mem_signed.
logic DEFAULT_co_mem_signed_a0;

// For |default$co_mem_word.
logic DEFAULT_co_mem_word_a0;

// For |default$co_mtval_pc.
logic DEFAULT_co_mtval_pc_a0;

// For |default$co_op_b_source.
logic DEFAULT_co_op_b_source_a0;

// For |default$co_rd_alu_en.
logic DEFAULT_co_rd_alu_en_a0;

// For |default$co_rd_csr_en.
logic DEFAULT_co_rd_csr_en_a0;

// For |default$co_rd_mem_en.
logic DEFAULT_co_rd_mem_en_a0;

// For |default$co_rd_op.
logic DEFAULT_co_rd_op_a0;

// For |default$co_sh_right.
logic DEFAULT_co_sh_right_a0;

// For |default$co_shift_op.
logic DEFAULT_co_shift_op_a0;

// For |default$co_two_stage_op.
logic DEFAULT_co_two_stage_op_a0;

// For |default$csr_op.
logic DEFAULT_csr_op_a0;

// For |default$csr_valid.
logic DEFAULT_csr_valid_a0;

// For |default$funct3.
logic [2:0] DEFAULT_funct3_a0;

// For |default$imm25.
logic DEFAULT_imm25_a0;

// For |default$imm30.
logic DEFAULT_imm30_a0;

// For |default$op20.
logic DEFAULT_op20_a0;

// For |default$op21.
logic DEFAULT_op21_a0;

// For |default$op22.
logic DEFAULT_op22_a0;

// For |default$op26.
logic DEFAULT_op26_a0;

// For |default$opcode.
logic [4:0] DEFAULT_opcode_a0;

// For |default$wb_en.
logic DEFAULT_wb_en_a0;

// For |default$wb_rdt.
logic [31:2] DEFAULT_wb_rdt_a0;


// ---------- Generated Code Ends ----------
//_\TLV
   //_|default
      //_@0
         // Connect Verilog inputs to pipesignals
         assign DEFAULT_wb_rdt_a0[31:2] = i_wb_rdt;
         assign DEFAULT_wb_en_a0 = i_wb_en;

         /*SV_plus*/


         assign DEFAULT_co_mdu_op_a0 = MDU & (DEFAULT_opcode_a0 == 5'b01100) & DEFAULT_imm25_a0;


         assign DEFAULT_co_two_stage_op_a0 =
              ~DEFAULT_opcode_a0[2] | (DEFAULT_funct3_a0[0] & ~DEFAULT_funct3_a0[1] & ~DEFAULT_opcode_a0[0] & ~DEFAULT_opcode_a0[4]) |
              (DEFAULT_funct3_a0[1] & ~DEFAULT_funct3_a0[2] & ~DEFAULT_opcode_a0[0] & ~DEFAULT_opcode_a0[4]) | DEFAULT_co_mdu_op_a0;


         assign DEFAULT_co_shift_op_a0 = (DEFAULT_opcode_a0[2] & ~DEFAULT_funct3_a0[1]) & !DEFAULT_co_mdu_op_a0;
         assign DEFAULT_co_branch_op_a0 = DEFAULT_opcode_a0[4];
         assign DEFAULT_co_dbus_en_a0 = ~DEFAULT_opcode_a0[2] & ~DEFAULT_opcode_a0[4];
         assign DEFAULT_co_mtval_pc_a0 = DEFAULT_opcode_a0[4];
         assign DEFAULT_co_mem_word_a0 = DEFAULT_funct3_a0[1];
         assign DEFAULT_co_rd_alu_en_a0 = !DEFAULT_opcode_a0[0] & DEFAULT_opcode_a0[2] & !DEFAULT_opcode_a0[4] & !DEFAULT_co_mdu_op_a0;
         assign DEFAULT_co_rd_mem_en_a0 = (!DEFAULT_opcode_a0[2] & !DEFAULT_opcode_a0[0]) | DEFAULT_co_mdu_op_a0;
         assign DEFAULT_co_ext_funct3_a0[2:0] = DEFAULT_funct3_a0;


         //jal,branch =     imm
         //jalr       = rs1+imm
         //mem        = rs1+imm
         //shift      = rs1
         assign DEFAULT_co_bufreg_rs1_en_a0 = !DEFAULT_opcode_a0[4] | (!DEFAULT_opcode_a0[1] & DEFAULT_opcode_a0[0]);
         assign DEFAULT_co_bufreg_imm_en_a0 = !DEFAULT_opcode_a0[2];

         //Clear LSB of immediate for BRANCH and JAL ops
         //True for BRANCH and JAL
         //False for JALR/LOAD/STORE/OP/OPIMM?
         assign DEFAULT_co_bufreg_clr_lsb_a0 = DEFAULT_opcode_a0[4] & ((DEFAULT_opcode_a0[1 : 0] == 2'b00) | (DEFAULT_opcode_a0[1 : 0] == 2'b11));


         //Conditional branch
         //True for BRANCH
         //False for JAL/JALR
         assign DEFAULT_co_cond_branch_a0 = !DEFAULT_opcode_a0[0];

         assign DEFAULT_co_ctrl_utype_a0 = !DEFAULT_opcode_a0[4] & DEFAULT_opcode_a0[2] & DEFAULT_opcode_a0[0];
         assign DEFAULT_co_ctrl_jal_or_jalr_a0 = DEFAULT_opcode_a0[4] & DEFAULT_opcode_a0[0];

         //PC-relative operations
         //True for jal, b* auipc, ebreak
         //False for jalr, lui
         assign DEFAULT_co_ctrl_pc_rel_a0 = (DEFAULT_opcode_a0[2 : 0] == 3'b000)  |
                        (DEFAULT_opcode_a0[1 : 0] == 2'b11)  |
                        (DEFAULT_opcode_a0[4] & DEFAULT_opcode_a0[2]) & DEFAULT_op20_a0|
                        (DEFAULT_opcode_a0[4 : 3] == 2'b00);
         //Write to RD
         //True for OP-IMM, AUIPC, OP, LUI, SYSTEM, JALR, JAL, LOAD
         //False for STORE, BRANCH, MISC-MEM
         assign DEFAULT_co_rd_op_a0 = (DEFAULT_opcode_a0[2] |
                   (!DEFAULT_opcode_a0[2] & DEFAULT_opcode_a0[4] & DEFAULT_opcode_a0[0]) |
                   (!DEFAULT_opcode_a0[2] & !DEFAULT_opcode_a0[3] & !DEFAULT_opcode_a0[0]));


         //
         //funct3
         //

         assign DEFAULT_co_sh_right_a0 = DEFAULT_funct3_a0[2];
         assign DEFAULT_co_bne_or_bge_a0 = DEFAULT_funct3_a0[0];

         //Matches system ops except eceall/ebreak/mret
         assign DEFAULT_csr_op_a0 = DEFAULT_opcode_a0[4] & DEFAULT_opcode_a0[2] & (|DEFAULT_funct3_a0);



         //op20
         assign DEFAULT_co_ebreak_a0 = DEFAULT_op20_a0;


         //opcode & funct3 & op21
         assign DEFAULT_co_ctrl_mret_a0 = DEFAULT_opcode_a0[4] & DEFAULT_opcode_a0[2] & DEFAULT_op21_a0 & !(|DEFAULT_funct3_a0);
         //Matches system opcodes except CSR accesses (funct3 == 0)
         //and mret (!op21)
         assign DEFAULT_co_e_op_a0 = DEFAULT_opcode_a0[4] & DEFAULT_opcode_a0[2] & !DEFAULT_op21_a0 & !(|DEFAULT_funct3_a0);

            //opcode & funct3 & imm30


         //opcode & funct3 & imm30
         assign DEFAULT_co_bufreg_sh_signed_a0 = DEFAULT_imm30_a0;

         /*
          True for sub, b*, slt*
          False for add*
          op    opcode f3  i30
          b*    11000  xxx x   t
          addi  00100  000 x   f
          slt*  0x100  01x x   t
          add   01100  000 0   f
          sub   01100  000 1   t
          */
         assign DEFAULT_co_alu_sub_a0 = DEFAULT_funct3_a0[1] | DEFAULT_funct3_a0[0] | (DEFAULT_opcode_a0[3] & DEFAULT_imm30_a0) | DEFAULT_opcode_a0[4];


         /*
          Bits 26, 22, 21 and 20 are enough to uniquely identify the eight supported CSR regs
          mtvec, mscratch, mepc and mtval are stored externally (normally in the RF) and are
          treated differently from mstatus, mie and mcause which are stored in serv_csr.

          The former get a 2-bit address as seen below while the latter get a
          one-hot enable signal each.

          Hex|2 222|Reg     |csr
          adr|6 210|name    |addr
          ---|-----|--------|----
          300|0_000|mstatus | xx
          304|0_100|mie     | xx
          305|0_101|mtvec   | 01
          340|1_000|mscratch| 00
          341|1_001|mepc    | 10
          342|1_010|mcause  | xx
          343|1_011|mtval   | 11

          */

         //true  for mtvec,mscratch,mepc and mtval
         //false for mstatus, mie, mcause
         assign DEFAULT_csr_valid_a0 = DEFAULT_op20_a0 | (DEFAULT_op26_a0 & !DEFAULT_op21_a0);

         assign DEFAULT_co_rd_csr_en_a0 = DEFAULT_csr_op_a0;

         assign DEFAULT_co_csr_en_a0 = DEFAULT_csr_op_a0 & DEFAULT_csr_valid_a0;
         assign DEFAULT_co_csr_mstatus_en_a0 = DEFAULT_csr_op_a0 & !DEFAULT_op26_a0 & !DEFAULT_op22_a0 & !DEFAULT_op20_a0;
         assign DEFAULT_co_csr_mie_en_a0 = DEFAULT_csr_op_a0 & !DEFAULT_op26_a0 & DEFAULT_op22_a0 & !DEFAULT_op20_a0;
         assign DEFAULT_co_csr_mcause_en_a0 = DEFAULT_csr_op_a0 & DEFAULT_op21_a0 & !DEFAULT_op20_a0;

         assign DEFAULT_co_csr_source_a0[1:0] = DEFAULT_funct3_a0[1 : 0];
         assign DEFAULT_co_csr_d_sel_a0 = DEFAULT_funct3_a0[2];
         assign DEFAULT_co_csr_imm_en_a0 = DEFAULT_opcode_a0[4] & DEFAULT_opcode_a0[2] & DEFAULT_funct3_a0[2];
         assign DEFAULT_co_csr_addr_a0[1:0] = {DEFAULT_op26_a0 & DEFAULT_op20_a0, !DEFAULT_op26_a0 | DEFAULT_op21_a0};


         assign DEFAULT_co_alu_cmp_eq_a0 = DEFAULT_funct3_a0[2 : 1] == 2'b00;
         assign DEFAULT_co_alu_cmp_sig_a0 = ~((DEFAULT_funct3_a0[0] & DEFAULT_funct3_a0[1]) | (DEFAULT_funct3_a0[1] & DEFAULT_funct3_a0[2]));


         assign DEFAULT_co_mem_cmd_a0  = DEFAULT_opcode_a0[3];
         assign DEFAULT_co_mem_signed_a0 = ~DEFAULT_funct3_a0[2];
         assign DEFAULT_co_mem_half_a0   = DEFAULT_funct3_a0[0];


         assign DEFAULT_co_alu_bool_op_a0[1:0] = DEFAULT_funct3_a0[1 : 0];


         //Immediate decode control bits as vector assignment
         //[0]: True for S (STORE) or B (BRANCH) type instructions, False for J type instructions
         //[1]: True for OP-IMM, LOAD, STORE, JALR  (I S), False for LUI, AUIPC, JAL (U J)
         //[2]: opcode[4] & !opcode[0]
         //[3]: opcode[4]
         assign DEFAULT_co_immdec_ctrl_a0[3:0] = {DEFAULT_opcode_a0[4],
                                 DEFAULT_opcode_a0[4] & !DEFAULT_opcode_a0[0],
                                 (DEFAULT_opcode_a0[1 : 0] == 2'b00) | (DEFAULT_opcode_a0[2 : 1] == 2'b00),
                                 DEFAULT_opcode_a0[3 : 0] == 4'b1000};


         //Immediate decode enable bits as vector assignment
         //[3]: B I J S U
         //[2]: I J U
         //[1]: J U
         //[0]: B S
         assign DEFAULT_co_immdec_en_a0[3:0] = {DEFAULT_opcode_a0[4] | DEFAULT_opcode_a0[3] | DEFAULT_opcode_a0[2] | !DEFAULT_opcode_a0[0],                 //B I J S U
                               (DEFAULT_opcode_a0[4] & DEFAULT_opcode_a0[2]) | !DEFAULT_opcode_a0[3] | DEFAULT_opcode_a0[0],               //  I J   U
                               (DEFAULT_opcode_a0[2 : 1] == 2'b01) | (DEFAULT_opcode_a0[2] & DEFAULT_opcode_a0[0]) | DEFAULT_co_csr_imm_en_a0,//    J   U
                               ~DEFAULT_co_rd_op_a0};                                                       //B     S


         //ALU result select bits as vector assignment
         //[2]: Bool
         //[1]: SLT*
         //[0]: Add/sub
         assign DEFAULT_co_alu_rd_sel_a0[2:0] = {DEFAULT_funct3_a0[2],                        //Bool
                                (DEFAULT_funct3_a0[2 : 1] == 2'b01),         //SLT*
                                (DEFAULT_funct3_a0 == 3'b000)};              // Add/sub


         //0 (OP_B_SOURCE_IMM) when OPIMM
         //1 (OP_B_SOURCE_RS2) when BRANCH or OP
         assign DEFAULT_co_op_b_source_a0 = DEFAULT_opcode_a0[3];

         // Connect pipesignals to Verilog outputs
         assign o_sh_right = DEFAULT_co_sh_right_a0;
         assign o_bne_or_bge = DEFAULT_co_bne_or_bge_a0;
         assign o_cond_branch = DEFAULT_co_cond_branch_a0;
         assign o_e_op = DEFAULT_co_e_op_a0;
         assign o_ebreak = DEFAULT_co_ebreak_a0;
         assign o_branch_op = DEFAULT_co_branch_op_a0;
         assign o_shift_op = DEFAULT_co_shift_op_a0;
         assign o_rd_op = DEFAULT_co_rd_op_a0;
         assign o_two_stage_op = DEFAULT_co_two_stage_op_a0;
         assign o_dbus_en = DEFAULT_co_dbus_en_a0;
         assign o_mdu_op = DEFAULT_co_mdu_op_a0;
         assign o_ext_funct3 = DEFAULT_co_ext_funct3_a0;
         assign o_bufreg_rs1_en = DEFAULT_co_bufreg_rs1_en_a0;
         assign o_bufreg_imm_en = DEFAULT_co_bufreg_imm_en_a0;
         assign o_bufreg_clr_lsb = DEFAULT_co_bufreg_clr_lsb_a0;
         assign o_bufreg_sh_signed = DEFAULT_co_bufreg_sh_signed_a0;
         assign o_ctrl_jal_or_jalr = DEFAULT_co_ctrl_jal_or_jalr_a0;
         assign o_ctrl_utype = DEFAULT_co_ctrl_utype_a0;
         assign o_ctrl_pc_rel = DEFAULT_co_ctrl_pc_rel_a0;
         assign o_ctrl_mret = DEFAULT_co_ctrl_mret_a0;
         assign o_alu_sub = DEFAULT_co_alu_sub_a0;
         assign o_alu_bool_op = DEFAULT_co_alu_bool_op_a0;
         assign o_alu_cmp_eq = DEFAULT_co_alu_cmp_eq_a0;
         assign o_alu_cmp_sig = DEFAULT_co_alu_cmp_sig_a0;
         assign o_alu_rd_sel = DEFAULT_co_alu_rd_sel_a0;
         assign o_mem_signed = DEFAULT_co_mem_signed_a0;
         assign o_mem_word = DEFAULT_co_mem_word_a0;
         assign o_mem_half = DEFAULT_co_mem_half_a0;
         assign o_mem_cmd = DEFAULT_co_mem_cmd_a0;
         assign o_csr_en = DEFAULT_co_csr_en_a0;
         assign o_csr_addr = DEFAULT_co_csr_addr_a0;
         assign o_csr_mstatus_en = DEFAULT_co_csr_mstatus_en_a0;
         assign o_csr_mie_en = DEFAULT_co_csr_mie_en_a0;
         assign o_csr_mcause_en = DEFAULT_co_csr_mcause_en_a0;
         assign o_csr_source = DEFAULT_co_csr_source_a0;
         assign o_csr_d_sel = DEFAULT_co_csr_d_sel_a0;
         assign o_csr_imm_en = DEFAULT_co_csr_imm_en_a0;
         assign o_mtval_pc = DEFAULT_co_mtval_pc_a0;
         assign o_immdec_ctrl = DEFAULT_co_immdec_ctrl_a0;
         assign o_immdec_en = DEFAULT_co_immdec_en_a0;
         assign o_op_b_source = DEFAULT_co_op_b_source_a0;
         assign o_rd_mem_en = DEFAULT_co_rd_mem_en_a0;
         assign o_rd_csr_en = DEFAULT_co_rd_csr_en_a0;
         assign o_rd_alu_en = DEFAULT_co_rd_alu_en_a0;

         /*SV_plus*/
            generate
               if (PRE_REGISTER) begin : gen_pre_register

                  always @(posedge clk) begin
                     DEFAULT_funct3_a0[2:0] <= DEFAULT_wb_en_a0 ? DEFAULT_wb_rdt_a0[14 : 12] : DEFAULT_funct3_a0;
                     DEFAULT_imm30_a0  <= DEFAULT_wb_en_a0 ? DEFAULT_wb_rdt_a0[30] : DEFAULT_imm30_a0;
                     DEFAULT_imm25_a0  <= DEFAULT_wb_en_a0 ? DEFAULT_wb_rdt_a0[25] : DEFAULT_imm25_a0;
                     DEFAULT_opcode_a0[4:0] <= DEFAULT_wb_en_a0 ? DEFAULT_wb_rdt_a0[6 : 2] : DEFAULT_opcode_a0;
                     DEFAULT_op20_a0   <= DEFAULT_wb_en_a0 ? DEFAULT_wb_rdt_a0[20] : DEFAULT_op20_a0;
                     DEFAULT_op21_a0   <= DEFAULT_wb_en_a0 ? DEFAULT_wb_rdt_a0[21] : DEFAULT_op21_a0;
                     DEFAULT_op22_a0   <= DEFAULT_wb_en_a0 ? DEFAULT_wb_rdt_a0[22] : DEFAULT_op22_a0;
                     DEFAULT_op26_a0   <= DEFAULT_wb_en_a0 ? DEFAULT_wb_rdt_a0[26] : DEFAULT_op26_a0;
                  end

               end else begin : gen_post_register

                  always @(*) begin
                     DEFAULT_funct3_a0  = DEFAULT_wb_rdt_a0[14 : 12];
                     DEFAULT_imm30_a0   = DEFAULT_wb_rdt_a0[30];
                     DEFAULT_imm25_a0   = DEFAULT_wb_rdt_a0[25];
                     DEFAULT_opcode_a0  = DEFAULT_wb_rdt_a0[6 : 2];
                     DEFAULT_op20_a0    = DEFAULT_wb_rdt_a0[20];
                     DEFAULT_op21_a0    = DEFAULT_wb_rdt_a0[21];
                     DEFAULT_op22_a0    = DEFAULT_wb_rdt_a0[22];
                     DEFAULT_op26_a0    = DEFAULT_wb_rdt_a0[26];
                  end

               end
            endgenerate


//_\SV
endmodule


// Undefine macros defined by SandPiper.
`undef BOGUS_USE
