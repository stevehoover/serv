//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro
`include "sp_verilog.vh" //_\source wip.tlv 193

//_\SV
module serv_state
  #(parameter RESET_STRATEGY = "MINI",
    parameter [0:0] WITH_CSR = 1,
    parameter [0:0] ALIGN =0,
    parameter [0:0] MDU = 0,
    parameter       W = 1
  )
  (
   input wire              i_clk,
   input wire              i_rst,
   //State
   input wire              i_new_irq,
   input wire              i_alu_cmp,
   output wire              o_init,
   output wire             o_cnt_en,
   output wire              o_cnt0to3,
   output wire              o_cnt12to31,
   output wire              o_cnt0,
   output wire              o_cnt1,
   output wire              o_cnt2,
   output wire              o_cnt3,
   output wire              o_cnt7,
   output wire              o_cnt11,
   output wire              o_cnt12,
   output wire              o_cnt_done,
   output wire              o_bufreg_en,
   output wire              o_ctrl_pc_en,
   output reg              o_ctrl_jump,
   output wire              o_ctrl_trap,
   input wire              i_ctrl_misalign,
   input wire              i_sh_done,
   output wire [1:0] o_mem_bytecnt,
   input wire              i_mem_misalign,
   //Control
   input wire              i_bne_or_bge,
   input wire              i_cond_branch,
   input wire              i_dbus_en,
   input wire              i_two_stage_op,
   input wire              i_branch_op,
   input wire              i_shift_op,
   input wire              i_sh_right,
   input wire              i_alu_rd_sel1,
   input wire              i_rd_alu_en,
   input wire              i_e_op,
   input wire              i_rd_op,
   //MDU
   input wire              i_mdu_op,
   output wire              o_mdu_valid,
   //Extension
   input wire              i_mdu_ready,
   //External
   output wire              o_dbus_cyc,
   input wire              i_dbus_ack,
   output wire              o_ibus_cyc,
   input wire              i_ibus_ack,
   //RF Interface
   output wire              o_rf_rreq,
   output wire              o_rf_wreq,
   input wire              i_rf_ready,
   output wire              o_rf_rd_en);

`include "compiled_gen.sv" //_\TLV
   // Connect Verilog inputs:
   //_|default
      //_@0
         assign DEFAULT_reset_a0 = i_rst;
         assign DEFAULT_new_irq_a0 = i_new_irq;
         assign DEFAULT_alu_cmp_a0 = i_alu_cmp;
         assign DEFAULT_ctrl_misalign_a0 = i_ctrl_misalign;
         assign DEFAULT_sh_done_a0 = i_sh_done;
         assign DEFAULT_mem_misalign_a0 = i_mem_misalign;
         assign DEFAULT_bne_or_bge_a0 = i_bne_or_bge;
         assign DEFAULT_cond_branch_a0 = i_cond_branch;
         assign DEFAULT_dbus_en_a0 = i_dbus_en;
         assign DEFAULT_two_stage_op_a0 = i_two_stage_op;
         assign DEFAULT_branch_op_a0 = i_branch_op;
         assign DEFAULT_shift_op_a0 = i_shift_op;
         assign DEFAULT_sh_right_a0 = i_sh_right;
         assign DEFAULT_alu_rd_sel1_a0 = i_alu_rd_sel1;
         assign DEFAULT_rd_alu_en_a0 = i_rd_alu_en;
         assign DEFAULT_e_op_a0 = i_e_op;
         assign DEFAULT_rd_op_a0 = i_rd_op;
         assign DEFAULT_mdu_op_a0 = i_mdu_op;
         assign DEFAULT_mdu_ready_a0 = i_mdu_ready;
         assign DEFAULT_dbus_ack_a0 = i_dbus_ack;
         assign DEFAULT_ibus_ack_a0 = i_ibus_ack;
         assign DEFAULT_rf_ready_a0 = i_rf_ready;

   //_\source wip.tlv 6   // Instantiated from wip.tlv, 284 as: m5+serv_state(/top)
      //_|default
         //_@0
            /*
             Because SERV is 32-bit bit-serial we need a counter than can count 0-31
             to keep track of which bit we are currently processing. out_cnt and cnt_r
             are used together to create such a counter.
             The top three bits (out_cnt) are implemented as a normal counter, but
             instead of the two LSB, cnt_r is a 4-bit shift register which loops 0-3
             When cnt_r[3] is 1, out_cnt will be increased.
   
             The counting starts when the core is idle and the i_rf_ready signal
             comes in from the RF module by shifting in the i_rf_ready bit as LSB of
             the shift register. Counting is stopped by using o_cnt_done to block the
             bit that was supposed to be shifted into bit 0 of cnt_r.
   
             There are two benefit of doing the counter this way
             1. We only need to check four bits instead of five when we want to check
             if the counter is at a certain value. For 4-LUT architectures this means
             we only need one LUT instead of two for each comparison.
             2. We don't need a separate enable signal to turn on and off the counter
             between stages, which saves an extra FF and a unique control signal. We
             just need to check if cnt_r is not zero to see if the counter is
             currently running
             */
   
            generate for (cnt_w1 = W != 1 ? -1 : 0; cnt_w1 <= 0; cnt_w1=cnt_w1+1) begin : L1_DEFAULT_CntW1 //_/cnt_w1

               // For $cnt_lsb.
               wire [3:0] L1_cnt_lsb_n1;
               reg  [3:0] L1_cnt_lsb_a0;

               // For $cnt_r_w1.
               wire [3:0] L1_cnt_r_w1_a0;

               // For $o_cnt_en_w1.
               wire L1_o_cnt_en_w1_a0;

               // For $out_cnt_inc_w1.
               wire [2:0] L1_out_cnt_inc_w1_a0;

               // Counter implementation for W=1 parameter configuration
               assign L1_cnt_lsb_n1[3:0] = (DEFAULT_reset_a0 & (RESET_STRATEGY != "NONE")) ? 4'b0000 :
                                  {L1_cnt_lsb_a0[2:0],(L1_cnt_lsb_a0[3] & !DEFAULT_cnt_done_out_a0) | DEFAULT_rf_ready_a0};
   
               assign L1_cnt_r_w1_a0[3:0] = L1_cnt_lsb_a0;
               assign L1_o_cnt_en_w1_a0 = | L1_cnt_lsb_a0;
               assign L1_out_cnt_inc_w1_a0[2:0] = {2'd0, L1_cnt_r_w1_a0[3]};
            end endgenerate
   
            generate for (cnt_w4 = W != 4 ? -1 : 0; cnt_w4 <= 0; cnt_w4=cnt_w4+1) begin : L1_DEFAULT_CntW4 //_/cnt_w4

               // For $cnt_en.
               wire L1_cnt_en_n1;
               reg  L1_cnt_en_a0;

               // For $cnt_r_w4.
               wire [3:0] L1_cnt_r_w4_a0;

               // For $o_cnt_en_w4.
               wire L1_o_cnt_en_w4_a0;

               // For $out_cnt_inc_w4.
               wire [2:0] L1_out_cnt_inc_w4_a0;

               // Counter implementation for W=4 parameter configuration
               assign L1_cnt_en_n1 = (DEFAULT_reset_a0 & (RESET_STRATEGY != "NONE")) ? 1'b0 :
                            DEFAULT_rf_ready_a0 ? 1'b1 :
                            DEFAULT_cnt_done_out_a0 ? 1'b0 : L1_cnt_en_a0;
   
               assign L1_cnt_r_w4_a0[3:0] = 4'b1111;
               assign L1_o_cnt_en_w4_a0 = L1_cnt_en_a0;
               assign L1_out_cnt_inc_w4_a0[2:0] = {2'd0, L1_cnt_en_a0};
            end endgenerate
   
            generate for (csr = !WITH_CSR ? -1 : 0; csr <= 0; csr=csr+1) begin : L1_DEFAULT_Csr //_/csr

               // For $misalign_trap_sync_r.
               wire L1_misalign_trap_sync_r_n1;
               reg  L1_misalign_trap_sync_r_a0;

               // CSR misalign trap synchronization logic
               assign L1_misalign_trap_sync_r_n1 = (DEFAULT_ibus_ack_a0 | DEFAULT_cnt_done_out_a0 | DEFAULT_reset_a0) ?
                                          (!(DEFAULT_ibus_ack_a0 | DEFAULT_reset_a0) & ((DEFAULT_trap_pending_a0 & DEFAULT_init_out_a0) | L1_misalign_trap_sync_r_a0)) :
                                          L1_misalign_trap_sync_r_a0;
            end endgenerate
   
            // Counter signal connections - parameter-dependent selection
            assign DEFAULT_cnt_r_a0[3:0] = (W == 1) ? L1_DEFAULT_CntW1[0].L1_cnt_r_w1_a0 : L1_DEFAULT_CntW4[0].L1_cnt_r_w4_a0;
            assign DEFAULT_o_cnt_en_a0 = (W == 1) ? L1_DEFAULT_CntW1[0].L1_o_cnt_en_w1_a0 : L1_DEFAULT_CntW4[0].L1_o_cnt_en_w4_a0;
            assign DEFAULT_out_cnt_inc_a0[2:0] = (W == 1) ? L1_DEFAULT_CntW1[0].L1_out_cnt_inc_w1_a0 : L1_DEFAULT_CntW4[0].L1_out_cnt_inc_w4_a0;
   
            // Branch condition evaluation
            //Take branch for jump or branch instructions (opcode == 1x0xx) if
            //a) It's an unconditional branch (opcode[0] == 1)
            //b) It's a conditional branch (opcode[0] == 0) of type beq,blt,bltu (funct3[0] == 0) and ALU compare is true
            //c) It's a conditional branch (opcode[0] == 0) of type bne,bge,bgeu (funct3[0] == 1) and ALU compare is false
            //Only valid during the last cycle of INIT, when the branch condition has
            //been calculated.
            assign DEFAULT_take_branch_a0 = DEFAULT_branch_op_a0 & (!DEFAULT_cond_branch_a0 | (DEFAULT_alu_cmp_a0^DEFAULT_bne_or_bge_a0));
   
            assign DEFAULT_last_init_a0 = DEFAULT_cnt_done_out_a0 & DEFAULT_init_out_a0;
   
            // CSR and trap handling
            //trap_pending is only guaranteed to have correct value during the
            // last cycle of the init stage
            assign DEFAULT_trap_pending_a0 = WITH_CSR & ((DEFAULT_take_branch_a0 & DEFAULT_ctrl_misalign_a0 & !ALIGN) |
                                        (DEFAULT_dbus_en_a0 & DEFAULT_mem_misalign_a0));
   
            assign DEFAULT_misalign_trap_sync_a0 = (WITH_CSR) ? L1_DEFAULT_Csr[0].L1_misalign_trap_sync_r_a0 : 1'b0;
            assign DEFAULT_ctrl_trap_out_a0 = WITH_CSR & (DEFAULT_e_op_a0 | DEFAULT_new_irq_a0 | DEFAULT_misalign_trap_sync_a0);
   
            // Core state outputs
            assign DEFAULT_ibus_cyc_out_a0 = DEFAULT_ibus_cyc_a0 & !DEFAULT_reset_a0;
            assign DEFAULT_init_out_a0 = DEFAULT_two_stage_op_a0 & !DEFAULT_new_irq_a0 & !DEFAULT_init_done_a0;
            assign DEFAULT_cnt_done_out_a0 = (DEFAULT_out_cnt_a0[4:2] == 3'b111) & DEFAULT_cnt_r_a0[3];
   
            // Memory interface
            assign DEFAULT_mem_bytecnt_out_a0[1:0] = DEFAULT_out_cnt_a0[4:3];
   
            // Counter bit outputs
            assign DEFAULT_cnt0_out_a0 = (DEFAULT_out_cnt_a0[4:2] == 3'd0) & DEFAULT_cnt_r_a0[0];
            assign DEFAULT_cnt1_out_a0 = (DEFAULT_out_cnt_a0[4:2] == 3'd0) & DEFAULT_cnt_r_a0[1];
            assign DEFAULT_cnt2_out_a0 = (DEFAULT_out_cnt_a0[4:2] == 3'd0) & DEFAULT_cnt_r_a0[2];
            assign DEFAULT_cnt3_out_a0 = (DEFAULT_out_cnt_a0[4:2] == 3'd0) & DEFAULT_cnt_r_a0[3];
            assign DEFAULT_cnt7_out_a0 = (DEFAULT_out_cnt_a0[4:2] == 3'd1) & DEFAULT_cnt_r_a0[3];
            assign DEFAULT_cnt11_out_a0 = (DEFAULT_out_cnt_a0[4:2] == 3'd2) & DEFAULT_cnt_r_a0[3];
            assign DEFAULT_cnt12_out_a0 = (DEFAULT_out_cnt_a0[4:2] == 3'd3) & DEFAULT_cnt_r_a0[0];
   
            // Counter range outputs
            assign DEFAULT_cnt0to3_out_a0 = (DEFAULT_out_cnt_a0[4:2] == 3'd0);
            assign DEFAULT_cnt12to31_out_a0 = (DEFAULT_out_cnt_a0[4] | (DEFAULT_out_cnt_a0[3:2] == 2'b11));
   
            // Control outputs
            //Update PC in RUN or TRAP states
            assign DEFAULT_ctrl_pc_en_out_a0 = DEFAULT_o_cnt_en_a0 & !DEFAULT_init_out_a0;
   
            assign DEFAULT_dbus_cyc_out_a0 = !DEFAULT_o_cnt_en_a0 & DEFAULT_init_done_a0 & DEFAULT_dbus_en_a0 & !DEFAULT_mem_misalign_a0;
   
            //valid signal for mdu
            assign DEFAULT_mdu_valid_out_a0 = MDU & !DEFAULT_o_cnt_en_a0 & DEFAULT_init_done_a0 & DEFAULT_mdu_op_a0;
   
            //Prepare RF for writes when everything is ready to enter stage two
            // and the first stage didn't cause a misalign exception
            //Left shifts, SLT & Branch ops. First cycle after init
            //Right shift. o_sh_done
            //Mem ops. i_dbus_ack
            //MDU ops. i_mdu_ready
            assign DEFAULT_rf_wreq_out_a0 = (DEFAULT_shift_op_a0 & (DEFAULT_sh_right_a0 ? (DEFAULT_sh_done_a0 & (DEFAULT_last_init_a0 | (!DEFAULT_o_cnt_en_a0 & DEFAULT_init_done_a0))) : DEFAULT_last_init_a0)) |
                           DEFAULT_dbus_ack_a0 | (MDU & DEFAULT_mdu_ready_a0) |
                           (DEFAULT_branch_op_a0 & (DEFAULT_last_init_a0 & !DEFAULT_trap_pending_a0)) |
                           (DEFAULT_rd_alu_en_a0 & DEFAULT_alu_rd_sel1_a0 & DEFAULT_last_init_a0);
   
            //Prepare RF for reads when a new instruction is fetched
            // or when stage one caused an exception (rreq implies a write request too)
            assign DEFAULT_rf_rreq_out_a0 = DEFAULT_ibus_ack_a0 | (DEFAULT_trap_pending_a0 & DEFAULT_last_init_a0);
   
            assign DEFAULT_rf_rd_en_out_a0 = DEFAULT_rd_op_a0 & !DEFAULT_init_out_a0;
   
            /*
             bufreg is used during mem, branch, and shift operations
   
             mem : bufreg is used for dbus address. Shift in data during phase 1.
                   Shift out during phase 2 if there was a misalignment exception.
   
             branch : Shift in during phase 1. Shift out during phase 2
   
             shift : Shift in during phase 1. Continue shifting between phases (except
                     for the first cycle after init). Shift out during phase 2
             */
            assign DEFAULT_bufreg_en_out_a0 = (DEFAULT_o_cnt_en_a0 & (DEFAULT_init_out_a0 | ((DEFAULT_ctrl_trap_out_a0 | DEFAULT_branch_op_a0) & DEFAULT_two_stage_op_a0))) | (DEFAULT_shift_op_a0 & DEFAULT_init_done_a0 & (DEFAULT_sh_right_a0 | DEFAULT_sh_done_a0));
   
   
            // Sequential state elements
            //ibus_cyc changes on three conditions.
            //1. i_rst is asserted. Together with the async gating above, o_ibus_cyc
            //   will be asserted as soon as the reset is released. This is how the
            //   first instruction is fetched
            //2. o_cnt_done and o_ctrl_pc_en are asserted. This means that SERV just
            //   finished updating the PC, is done with the current instruction and
            //   o_ibus_cyc gets asserted to fetch a new instruction
            //3. When i_ibus_ack, a new instruction is fetched and o_ibus_cyc gets
            //   deasserted to finish the transaction
            assign DEFAULT_ibus_cyc_n1 = (DEFAULT_ibus_ack_a0 | DEFAULT_cnt_done_out_a0 | DEFAULT_reset_a0) ? (DEFAULT_ctrl_pc_en_out_a0 | DEFAULT_reset_a0) : DEFAULT_ibus_cyc_a0;
   
            assign DEFAULT_init_done_n1 = DEFAULT_reset_a0 ? ((RESET_STRATEGY != "NONE") ? 1'b0 : DEFAULT_init_done_a0) :
                            DEFAULT_cnt_done_out_a0 ? (DEFAULT_init_out_a0 & !DEFAULT_init_done_a0) : DEFAULT_init_done_a0;
   
            assign DEFAULT_ctrl_jump_n1 = (DEFAULT_reset_a0 && (RESET_STRATEGY != "NONE")) ? 1'b0 :
                             (DEFAULT_cnt_done_out_a0) ? (DEFAULT_init_out_a0 & DEFAULT_take_branch_a0) :
                             DEFAULT_ctrl_jump_a0;
   
            // Counter increment - top 3 bits of the bit counter
            assign DEFAULT_out_cnt_n1[4:2] = (DEFAULT_reset_a0 && (RESET_STRATEGY != "NONE")) ? 3'd0 : (DEFAULT_out_cnt_a0[4:2] + DEFAULT_out_cnt_inc_a0[2:0]);
   
            // Connect TLV signals to SV wires (for SV_plus usage):
            assign init_done = DEFAULT_init_done_a0;
            assign last_init = DEFAULT_last_init_a0;
            assign trap_pending = DEFAULT_trap_pending_a0;
   
            // Connect Verilog outputs:
            assign o_init = DEFAULT_init_out_a0;
            assign o_cnt_en = DEFAULT_o_cnt_en_a0;
            assign o_cnt0to3 = DEFAULT_cnt0to3_out_a0;
            assign o_cnt12to31 = DEFAULT_cnt12to31_out_a0;
            assign o_cnt0 = DEFAULT_cnt0_out_a0;
            assign o_cnt1 = DEFAULT_cnt1_out_a0;
            assign o_cnt2 = DEFAULT_cnt2_out_a0;
            assign o_cnt3 = DEFAULT_cnt3_out_a0;
            assign o_cnt7 = DEFAULT_cnt7_out_a0;
            assign o_cnt11 = DEFAULT_cnt11_out_a0;
            assign o_cnt12 = DEFAULT_cnt12_out_a0;
            assign o_cnt_done = DEFAULT_cnt_done_out_a0;
            assign o_ctrl_pc_en = DEFAULT_ctrl_pc_en_out_a0;
            assign o_ctrl_jump = DEFAULT_ctrl_jump_a0;
            assign o_ctrl_trap = DEFAULT_ctrl_trap_out_a0;
            assign o_dbus_cyc = DEFAULT_dbus_cyc_out_a0;
            assign o_mdu_valid = DEFAULT_mdu_valid_out_a0;
            assign o_mem_bytecnt = DEFAULT_mem_bytecnt_out_a0;
            assign o_ibus_cyc = DEFAULT_ibus_cyc_out_a0;
            assign o_rf_rreq = DEFAULT_rf_rreq_out_a0;
            assign o_rf_wreq = DEFAULT_rf_wreq_out_a0;
            assign o_rf_rd_en = DEFAULT_rf_rd_en_out_a0;
            assign o_bufreg_en = DEFAULT_bufreg_en_out_a0;
   //_\end_source


   // Connect Verilog outputs:
   //_|default
      //_@0
         assign o_init = DEFAULT_init_out_a0;
         assign o_cnt_en = DEFAULT_o_cnt_en_a0;
         assign o_cnt0to3 = DEFAULT_cnt0to3_out_a0;
         assign o_cnt12to31 = DEFAULT_cnt12to31_out_a0;
         assign o_cnt0 = DEFAULT_cnt0_out_a0;
         assign o_cnt1 = DEFAULT_cnt1_out_a0;
         assign o_cnt2 = DEFAULT_cnt2_out_a0;
         assign o_cnt3 = DEFAULT_cnt3_out_a0;
         assign o_cnt7 = DEFAULT_cnt7_out_a0;
         assign o_cnt11 = DEFAULT_cnt11_out_a0;
         assign o_cnt12 = DEFAULT_cnt12_out_a0;
         assign o_cnt_done = DEFAULT_cnt_done_out_a0;
         assign o_ctrl_pc_en = DEFAULT_ctrl_pc_en_out_a0;
         assign o_ctrl_jump = DEFAULT_ctrl_jump_a0;
         assign o_ctrl_trap = DEFAULT_ctrl_trap_out_a0;
         assign o_dbus_cyc = DEFAULT_dbus_cyc_out_a0;
         assign o_mdu_valid = DEFAULT_mdu_valid_out_a0;
         assign o_mem_bytecnt = DEFAULT_mem_bytecnt_out_a0;
         assign o_ibus_cyc = DEFAULT_ibus_cyc_out_a0;
         assign o_rf_rreq = DEFAULT_rf_rreq_out_a0;
         assign o_rf_wreq = DEFAULT_rf_wreq_out_a0;
         assign o_rf_rd_en = DEFAULT_rf_rd_en_out_a0;
         assign o_bufreg_en = DEFAULT_bufreg_en_out_a0;

         /*SV_plus*/
            // Clock and reset signals for TL-Verilog convention
            wire clk = i_clk;
            wire reset = i_rst;


//_\SV
endmodule


// Undefine macros defined by SandPiper (in "compiled_gen.sv").
`undef BOGUS_USE
