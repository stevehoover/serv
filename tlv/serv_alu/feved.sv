`line 2 "wip.tlv" 0 //_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro
`line 4 "wip.tlv" 1
//_\SV  // This is a quirk of SandPiper, but include it.
`line 44 "wip.tlv" 1

//_\SV
`default_nettype none
module serv_alu
  #(
   parameter W = 1,
   parameter B = W-1
  )
  (
   input wire 	    clk,
   //State
   input wire 	    i_en,
   input wire 	    i_cnt0,
   output wire 	    o_cmp,
   //Control
   input wire 	    i_sub,
   input wire [1:0] i_bool_op,
   input wire 	    i_cmp_eq,
   input wire 	    i_cmp_sig,
   input wire [2:0] i_rd_sel,
   //Data
   input wire  [B:0] i_rs1,
   input wire  [B:0] i_op_b,
   input wire  [B:0] i_buf,
   output wire [B:0] o_rd);

// ---------- Generated Code Inlined Here (before 1st \TLV) ----------
`line 0 "wip.sv" 1
// Generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro from Redwood EDA, LLC.
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)





//
// Signals declared top-level.
//

// For |alu$add_bb.
logic [B:0] ALU_add_bb_a0;

// For |alu$add_carry.
logic ALU_add_carry_a0;

// For |alu$add_carry_r.
logic [B:0] ALU_add_carry_r_n1,
            ALU_add_carry_r_a0;

// For |alu$cmp_reg.
logic ALU_cmp_reg_n1,
      ALU_cmp_reg_a0;

// For |alu$ii_bool_op.
logic [1:0] ALU_ii_bool_op_a0;

// For |alu$ii_buf.
logic [B:0] ALU_ii_buf_a0;

// For |alu$ii_cmp_eq.
logic ALU_ii_cmp_eq_a0;

// For |alu$ii_cmp_sig.
logic ALU_ii_cmp_sig_a0;

// For |alu$ii_cnt0.
logic ALU_ii_cnt0_a0;

// For |alu$ii_en.
logic ALU_ii_en_a0;

// For |alu$ii_op_b.
logic [B:0] ALU_ii_op_b_a0;

// For |alu$ii_rd_sel.
logic [2:0] ALU_ii_rd_sel_a0;

// For |alu$ii_rs1.
logic [B:0] ALU_ii_rs1_a0;

// For |alu$ii_sub.
logic ALU_ii_sub_a0;

// For |alu$oo_cmp.
logic ALU_oo_cmp_a0;

// For |alu$oo_rd.
logic [B:0] ALU_oo_rd_a0;

// For |alu$op_bb_sx.
logic ALU_op_bb_sx_a0;

// For |alu$result_add.
logic [B:0] ALU_result_add_a0;

// For |alu$result_bool.
logic [B:0] ALU_result_bool_a0;

// For |alu$result_eq.
logic ALU_result_eq_a0;

// For |alu$result_lt.
logic ALU_result_lt_a0;

// For |alu$result_slt.
logic [B:0] ALU_result_slt_a0;

// For |alu$rrs1_sx.
logic ALU_rrs1_sx_a0;




   //
   // Scope: |alu
   //

      // Staging of $add_carry_r.
      always_ff @(posedge clk) ALU_add_carry_r_a0[B:0] <= ALU_add_carry_r_n1[B:0];

      // Staging of $cmp_reg.
      always_ff @(posedge clk) ALU_cmp_reg_a0 <= ALU_cmp_reg_n1;



// ---------- Generated Code Ends ----------
`line 72 "wip.tlv" 2
//_\TLV
   // Connect Verilog inputs:
   //_|alu
      //_@0
         assign ALU_ii_en_a0 = i_en;
         assign ALU_ii_cnt0_a0 = i_cnt0;
         assign ALU_ii_sub_a0 = i_sub;
         assign ALU_ii_bool_op_a0[1:0] = i_bool_op;
         assign ALU_ii_cmp_eq_a0 = i_cmp_eq;
         assign ALU_ii_cmp_sig_a0 = i_cmp_sig;
         assign ALU_ii_rd_sel_a0[2:0] = i_rd_sel;
         assign ALU_ii_rs1_a0[B:0] = i_rs1;
         assign ALU_ii_op_b_a0[B:0] = i_op_b;
         assign ALU_ii_buf_a0[B:0] = i_buf;

      //_@0
         `line 7 "wip.tlv" 1   // Instantiated from wip.tlv, 86 as: m5+serv_alu_logic(/top)
            // ALU Operations:
         
            // Sign-extended operands for comparison
            assign ALU_rrs1_sx_a0 = ALU_ii_rs1_a0[B] & ALU_ii_cmp_sig_a0;
            assign ALU_op_bb_sx_a0 = ALU_ii_op_b_a0[B] & ALU_ii_cmp_sig_a0;
         
            // Addition/Subtraction
            assign ALU_add_bb_a0[B:0] = ALU_ii_op_b_a0 ^ {W{ALU_ii_sub_a0}};
            assign {ALU_add_carry_a0, ALU_result_add_a0[B:0]} = ALU_ii_rs1_a0 + ALU_add_bb_a0 + ALU_add_carry_r_a0;
         
            // Comparison operations
            assign ALU_result_lt_a0 = ALU_rrs1_sx_a0 + ~ ALU_op_bb_sx_a0 + ALU_add_carry_a0;
            assign ALU_result_eq_a0 = ! (| ALU_result_add_a0) & (ALU_cmp_reg_a0 | ALU_ii_cnt0_a0);
            assign ALU_oo_cmp_a0 = ALU_ii_cmp_eq_a0 ? ALU_result_eq_a0 : ALU_result_lt_a0;
         
            // Boolean operations (XOR, OR, AND based on i_bool_op)
            /*
            The result_bool expression implements the following operations between
            i_rs1 and i_op_b depending on the value of i_bool_op:
            00 xor, 01 0, 10 or, 11 and
            i_bool_op will be 01 during shift operations, so by outputting zero under
            this condition we can safely or result_bool with i_buf
            */
            assign ALU_result_bool_a0[B:0] = ((ALU_ii_rs1_a0 ^ ALU_ii_op_b_a0) & ~ {W{ALU_ii_bool_op_a0[0]}}) | ({W{ALU_ii_bool_op_a0[1]}} & ALU_ii_op_b_a0 & ALU_ii_rs1_a0);
         
            // Set-less-than result
            assign ALU_result_slt_a0[B:0] = (W > 1) ? {{B{1'b0}}, ALU_cmp_reg_a0 & ALU_ii_cnt0_a0} : (ALU_cmp_reg_a0 & ALU_ii_cnt0_a0);
         
            // Result multiplexing and output assignment
            assign ALU_oo_rd_a0[B:0] = ALU_ii_buf_a0 |
                           ({W{ALU_ii_rd_sel_a0[0]}} & ALU_result_add_a0) |
                           ({W{ALU_ii_rd_sel_a0[1]}} & ALU_result_slt_a0) |
                           ({W{ALU_ii_rd_sel_a0[2]}} & ALU_result_bool_a0);
         
            // State register updates for next cycle
            assign ALU_add_carry_r_n1[B:0] = {{B{1'b0}}, (ALU_ii_en_a0 ? ALU_add_carry_a0 : ALU_ii_sub_a0)};
            assign ALU_cmp_reg_n1 = ALU_ii_en_a0 ? ALU_oo_cmp_a0 : ALU_cmp_reg_a0;
         //_\end_source
         `line 87 "wip.tlv" 2

   // Connect Verilog outputs:
   //_|alu
      //_@0
         assign o_cmp = ALU_oo_cmp_a0;
         assign o_rd = ALU_oo_rd_a0;

//_\SV
endmodule


// Undefine macros defined by SandPiper.
`undef BOGUS_USE
