//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro
//_\SV
module serv_bufreg2
  #(parameter W = 1,
    //Internally calculated. Do not touch
    parameter B=W-1)
  (
   input wire          clk,
   //State
   input wire          i_en,
   input wire          i_init,
   input wire          i_cnt7,
   input wire          i_cnt_done,
   input wire          i_sh_right,
   input wire [1:0]   i_lsb,
   input wire [1:0]   i_bytecnt,
   output wire          o_sh_done,
   //Control
   input wire          i_op_b_sel,
   input wire          i_shift_op,
   //Data
   input wire [B:0]   i_rs2,
   input wire [B:0]   i_imm,
   output wire [B:0]  o_op_b,
   output wire [B:0]  o_q,
   //External
   output wire [31:0] o_dat,
   input wire          i_load,
   input wire [31:0]  i_dat);
// ---------- Generated Code Inlined Here (before 1st \TLV) ----------
// Generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro from Redwood EDA, LLC.
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)





//
// Signals declared top-level.
//

// For |default$byte_valid.
logic DEFAULT_byte_valid_a0;

// For |default$bytecnt.
logic [1:0] DEFAULT_bytecnt_a0;

// For |default$cnt7.
logic DEFAULT_cnt7_a0;

// For |default$cnt_done.
logic DEFAULT_cnt_done_a0;

// For |default$cnt_en.
logic DEFAULT_cnt_en_a0;

// For |default$cnt_next.
logic [7:0] DEFAULT_cnt_next_a0;

// For |default$cnt_next_w_eq_1.
logic [7:0] DEFAULT_cnt_next_w_eq_1_a0;

// For |default$cnt_next_w_eq_4.
logic [7:0] DEFAULT_cnt_next_w_eq_4_a0;

// For |default$dat.
logic [31:0] DEFAULT_dat_a0;

// For |default$dat_combined.
logic [31:0] DEFAULT_dat_combined_a0;

// For |default$dat_shamt.
logic [7:0] DEFAULT_dat_shamt_a0;

// For |default$data_hi.
logic [7:0] DEFAULT_data_hi_n1,
            DEFAULT_data_hi_a0;

// For |default$data_lo.
logic [23:0] DEFAULT_data_lo_n1,
             DEFAULT_data_lo_a0;

// For |default$en.
logic DEFAULT_en_a0;

// For |default$imm.
logic [B:0] DEFAULT_imm_a0;

// For |default$init.
logic DEFAULT_init_a0;

// For |default$load.
logic DEFAULT_load_a0;

// For |default$lsb.
logic [1:0] DEFAULT_lsb_a0;

// For |default$op_b_sel.
logic DEFAULT_op_b_sel_a0;

// For |default$rs2.
logic [B:0] DEFAULT_rs2_a0;

// For |default$sh_right.
logic DEFAULT_sh_right_a0;

// For |default$shift_en.
logic DEFAULT_shift_en_a0;

// For |default$shift_op.
logic DEFAULT_shift_op_a0;




   //
   // Scope: |default
   //

      // Staging of $data_hi.
      always_ff @(posedge clk) DEFAULT_data_hi_a0[7:0] <= DEFAULT_data_hi_n1[7:0];

      // Staging of $data_lo.
      always_ff @(posedge clk) DEFAULT_data_lo_a0[23:0] <= DEFAULT_data_lo_n1[23:0];



// ---------- Generated Code Ends ----------
//_\TLV
   //_|default
      //_@0
         // Connect Verilog inputs:
         assign DEFAULT_en_a0 = i_en;
         assign DEFAULT_init_a0 = i_init;
         assign DEFAULT_cnt7_a0 = i_cnt7;
         assign DEFAULT_cnt_done_a0 = i_cnt_done;
         assign DEFAULT_sh_right_a0 = i_sh_right;
         assign DEFAULT_lsb_a0[1:0] = i_lsb;
         assign DEFAULT_bytecnt_a0[1:0] = i_bytecnt;
         assign DEFAULT_op_b_sel_a0 = i_op_b_sel;
         assign DEFAULT_shift_op_a0 = i_shift_op;
         assign DEFAULT_rs2_a0[B:0] = i_rs2;
         assign DEFAULT_imm_a0[B:0] = i_imm;
         assign DEFAULT_load_a0 = i_load;
         assign DEFAULT_dat_a0[31:0] = i_dat;

         // High and low data words form a 32-bit word

         /*
          Before a store operation, the data to be written needs to be shifted into
          place. Depending on the address alignment, we need to shift different
          amounts. One formula for calculating this is to say that we shift when
          i_lsb + i_bytecnt < 4. Unfortunately, the synthesis tools don't seem to be
          clever enough so the hideous expression below is used to achieve the same
          thing in a more optimal way.
          */
         assign DEFAULT_byte_valid_a0
           = (!DEFAULT_lsb_a0[0] & !DEFAULT_lsb_a0[1])         |
             (!DEFAULT_bytecnt_a0[0] & !DEFAULT_bytecnt_a0[1]) |
             (!DEFAULT_bytecnt_a0[1] & !DEFAULT_lsb_a0[1])     |
             (!DEFAULT_bytecnt_a0[1] & !DEFAULT_lsb_a0[0])     |
             (!DEFAULT_bytecnt_a0[0] & !DEFAULT_lsb_a0[1]);

         assign DEFAULT_shift_en_a0 = DEFAULT_shift_op_a0 ? (DEFAULT_en_a0 & DEFAULT_init_a0 & (DEFAULT_bytecnt_a0 == 2'b00)) : (DEFAULT_en_a0 & DEFAULT_byte_valid_a0);

         assign DEFAULT_cnt_en_a0 = (DEFAULT_shift_op_a0 & (!DEFAULT_init_a0 | (DEFAULT_cnt_done_a0 & DEFAULT_sh_right_a0)));

         /* The dat register has three different use cases for store, load and
          shift operations.
          store : Data to be written is shifted to the correct position in dat during
                  init by shift_en and is presented on the data bus as o_wb_dat
          load  : Data from the bus gets latched into dat during i_wb_ack and is then
                  shifted out at the appropriate time to end up in the correct
                  position in rd
          shift : Data is shifted in during init. After that, the six LSB are used as
                  a downcounter (with bit 5 initially set to 0) that trigger
                  o_sh_done when they wrap around to indicate that
                  the requested number of shifts have been performed
          */

         // Note: cnt_next logic with parameter-dependent ranges kept in \SV_plus
         // to avoid out-of-bounds access issues while maintaining FEV compatibility

         assign DEFAULT_dat_shamt_a0[7:0] = DEFAULT_cnt_en_a0 ?
                //Down counter mode
                DEFAULT_cnt_next_a0 :
                //Shift reg mode
                {(DEFAULT_op_b_sel_a0 ? DEFAULT_rs2_a0 : DEFAULT_imm_a0), DEFAULT_data_hi_a0[7 : W]};

         assign DEFAULT_data_hi_n1[7:0] = (DEFAULT_shift_en_a0 | DEFAULT_cnt_en_a0 | DEFAULT_load_a0) ? 
                            (DEFAULT_load_a0 ? DEFAULT_dat_a0[31:24] : DEFAULT_dat_shamt_a0 & {2'b11, !(DEFAULT_shift_op_a0 & DEFAULT_cnt7_a0 & !DEFAULT_cnt_en_a0), 5'b11111}) :
                            DEFAULT_data_hi_a0;
         assign DEFAULT_data_lo_n1[23:0] = (DEFAULT_shift_en_a0 | DEFAULT_load_a0) ? 
                             (DEFAULT_load_a0 ? DEFAULT_dat_a0[23:0] : {DEFAULT_data_hi_a0[B:0], DEFAULT_data_lo_a0[23:W]}) :
                             DEFAULT_data_lo_a0;

         /*SV_plus*/
            // Parameter-dependent logic that requires generate blocks for safe synthesis
            // Intermediate op_b signal for generate blocks  
            wire [B:0] op_b_internal = DEFAULT_op_b_sel_a0 ? DEFAULT_rs2_a0 : DEFAULT_imm_a0;
            
            generate
               if (W == 1) begin : gen_cnt_w_eq_1
                  assign DEFAULT_cnt_next_w_eq_1_a0[7:0] = {op_b_internal, DEFAULT_data_hi_a0[7], DEFAULT_data_hi_a0[5:0]-6'd1};
               end
               if (W == 4) begin : gen_cnt_w_eq_4  
                  assign DEFAULT_cnt_next_w_eq_4_a0[7:0] = {op_b_internal[3:2], DEFAULT_data_hi_a0[5:0]-6'd4};
               end
            endgenerate

            assign DEFAULT_cnt_next_a0[7:0] = (W == 1) ? DEFAULT_cnt_next_w_eq_1_a0 :
                                    (W == 4) ? DEFAULT_cnt_next_w_eq_4_a0 :
                                              8'h00; // default case

         // Intermediate signal for output data
         assign DEFAULT_dat_combined_a0[31:0] = {DEFAULT_data_hi_a0, DEFAULT_data_lo_a0};
         
         // Connect Verilog outputs:
         assign o_sh_done = DEFAULT_dat_shamt_a0[5];
         assign o_op_b = DEFAULT_op_b_sel_a0 ? DEFAULT_rs2_a0 : DEFAULT_imm_a0;
         assign o_q = ({W{(DEFAULT_lsb_a0 == 2'd3)}} & DEFAULT_dat_combined_a0[W+23:24]) |
                ({W{(DEFAULT_lsb_a0 == 2'd2)}} & DEFAULT_dat_combined_a0[W+15:16]) |
                ({W{(DEFAULT_lsb_a0 == 2'd1)}} & DEFAULT_dat_combined_a0[W+7:8])   |
                ({W{(DEFAULT_lsb_a0 == 2'd0)}} & DEFAULT_dat_combined_a0[W-1:0]);
         assign o_dat = DEFAULT_dat_combined_a0;
//_\SV
endmodule


// Undefine macros defined by SandPiper.
`undef BOGUS_USE
