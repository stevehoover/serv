//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro
//_\source wip.tlv 93

//_\SV
module serv_bufreg2
  #(parameter W = 1,
    //Internally calculated. Do not touch
    parameter B=W-1)
  (
   input wire          clk,
   //State
   input wire          i_en,
   input wire          i_init,
   input wire          i_cnt7,
   input wire          i_cnt_done,
   input wire          i_sh_right,
   input wire [1:0]   i_lsb,
   input wire [1:0]   i_bytecnt,
   output wire          o_sh_done,
   //Control
   input wire          i_op_b_sel,
   input wire          i_shift_op,
   //Data
   input wire [B:0]   i_rs2,
   input wire [B:0]   i_imm,
   output wire [B:0]  o_op_b,
   output wire [B:0]  o_q,
   //External
   output wire [31:0] o_dat,
   input wire          i_load,
   input wire [31:0]  i_dat);
// ---------- Generated Code Inlined Here (before 1st \TLV) ----------
// Generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro from Redwood EDA, LLC.
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)





//
// Signals declared top-level.
//

// For |default$byte_valid.
logic DEFAULT_byte_valid_a0;

// For |default$bytecnt.
logic [1:0] DEFAULT_bytecnt_a0;

// For |default$cnt7.
logic DEFAULT_cnt7_a0;

// For |default$cnt_done.
logic DEFAULT_cnt_done_a0;

// For |default$cnt_en.
logic DEFAULT_cnt_en_a0;

// For |default$cnt_next.
logic [7:0] DEFAULT_cnt_next_a0;

// For |default$cnt_next_w_eq_1.
logic [7:0] DEFAULT_cnt_next_w_eq_1_a0;

// For |default$cnt_next_w_eq_4.
logic [7:0] DEFAULT_cnt_next_w_eq_4_a0;

// For |default$dat.
logic [31:0] DEFAULT_dat_a0;

// For |default$dat_combined.
logic [31:0] DEFAULT_dat_combined_a0;

// For |default$dat_shamt.
logic [7:0] DEFAULT_dat_shamt_a0;

// For |default$data_hi.
logic [7:0] DEFAULT_data_hi_n1,
            DEFAULT_data_hi_a0;

// For |default$data_lo.
logic [23:0] DEFAULT_data_lo_n1,
             DEFAULT_data_lo_a0;

// For |default$en.
logic DEFAULT_en_a0;

// For |default$imm.
logic [B:0] DEFAULT_imm_a0;

// For |default$init.
logic DEFAULT_init_a0;

// For |default$load.
logic DEFAULT_load_a0;

// For |default$lsb.
logic [1:0] DEFAULT_lsb_a0;

// For |default$o_dat.
logic [31:0] DEFAULT_o_dat_a0;

// For |default$o_op_b.
logic [B:0] DEFAULT_o_op_b_a0;

// For |default$o_q.
logic [B:0] DEFAULT_o_q_a0;

// For |default$o_sh_done.
logic DEFAULT_o_sh_done_a0;

// For |default$op_b.
logic [B:0] DEFAULT_op_b_a0;

// For |default$op_b_sel.
logic DEFAULT_op_b_sel_a0;

// For |default$rs2.
logic [B:0] DEFAULT_rs2_a0;

// For |default$sh_right.
logic DEFAULT_sh_right_a0;

// For |default$shift_en.
logic DEFAULT_shift_en_a0;

// For |default$shift_op.
logic DEFAULT_shift_op_a0;




   //
   // Scope: |default
   //

      // Staging of $data_hi.
      always_ff @(posedge clk) DEFAULT_data_hi_a0[7:0] <= DEFAULT_data_hi_n1[7:0];

      // Staging of $data_lo.
      always_ff @(posedge clk) DEFAULT_data_lo_a0[23:0] <= DEFAULT_data_lo_n1[23:0];



// ---------- Generated Code Ends ----------
//_\TLV
   // Connect Verilog inputs:
   //_|default
      //_@0
         assign DEFAULT_en_a0 = i_en;
         assign DEFAULT_init_a0 = i_init;
         assign DEFAULT_cnt7_a0 = i_cnt7;
         assign DEFAULT_cnt_done_a0 = i_cnt_done;
         assign DEFAULT_sh_right_a0 = i_sh_right;
         assign DEFAULT_lsb_a0[1:0] = i_lsb;
         assign DEFAULT_bytecnt_a0[1:0] = i_bytecnt;
         assign DEFAULT_op_b_sel_a0 = i_op_b_sel;
         assign DEFAULT_shift_op_a0 = i_shift_op;
         assign DEFAULT_rs2_a0[B:0] = i_rs2;
         assign DEFAULT_imm_a0[B:0] = i_imm;
         assign DEFAULT_load_a0 = i_load;
         assign DEFAULT_dat_a0[31:0] = i_dat;

   // Instantiate the serv_bufreg2 macro
   //_\source wip.tlv 6   // Instantiated from wip.tlv, 142 as: m5+serv_bufreg2(/top)
      //_|default
         //_@0
            // === CONTROL LOGIC ===
   
            /*
             Before a store operation, the data to be written needs to be shifted into
             place. Depending on the address alignment, we need to shift different
             amounts. One formula for calculating this is to say that we shift when
             i_lsb + i_bytecnt < 4. Unfortunately, the synthesis tools don't seem to be
             clever enough so the hideous expression below is used to achieve the same
             thing in a more optimal way.
             */
            assign DEFAULT_byte_valid_a0
              = (!DEFAULT_lsb_a0[0] & !DEFAULT_lsb_a0[1])         |
                (!DEFAULT_bytecnt_a0[0] & !DEFAULT_bytecnt_a0[1]) |
                (!DEFAULT_bytecnt_a0[1] & !DEFAULT_lsb_a0[1])     |
                (!DEFAULT_bytecnt_a0[1] & !DEFAULT_lsb_a0[0])     |
                (!DEFAULT_bytecnt_a0[0] & !DEFAULT_lsb_a0[1]);
   
            assign DEFAULT_shift_en_a0 = DEFAULT_shift_op_a0 ? (DEFAULT_en_a0 & DEFAULT_init_a0 & (DEFAULT_bytecnt_a0 == 2'b00)) : (DEFAULT_en_a0 & DEFAULT_byte_valid_a0);
            assign DEFAULT_cnt_en_a0 = (DEFAULT_shift_op_a0 & (!DEFAULT_init_a0 | (DEFAULT_cnt_done_a0 & DEFAULT_sh_right_a0)));
   
            // === COMBINATIONAL LOGIC ===
   
            // Select between rs2 and immediate for op_b output
            assign DEFAULT_op_b_a0[B:0] = DEFAULT_op_b_sel_a0 ? DEFAULT_rs2_a0 : DEFAULT_imm_a0;
   
            // High and low data words form a 32-bit word
            assign DEFAULT_dat_combined_a0[31:0] = {DEFAULT_data_hi_a0, DEFAULT_data_lo_a0};
   
            /* The dat register has three different use cases for store, load and
             shift operations.
             store : Data to be written is shifted to the correct position in dat during
                     init by shift_en and is presented on the data bus as o_wb_dat
             load  : Data from the bus gets latched into dat during i_wb_ack and is then
                     shifted out at the appropriate time to end up in the correct
                     position in rd
             shift : Data is shifted in during init. After that, the six LSB are used as
                     a downcounter (with bit 5 initially set to 0) that trigger
                     o_sh_done when they wrap around to indicate that
                     the requested number of shifts have been performed
             */
   
            // Data shift amount logic with parameter-dependent counter
            assign DEFAULT_dat_shamt_a0[7:0] = DEFAULT_cnt_en_a0 ?
                   //Down counter mode
                   DEFAULT_cnt_next_a0 :
                   //Shift reg mode
                   {DEFAULT_op_b_a0, DEFAULT_data_hi_a0[7 : W]};
   
            // Parameter-dependent counter next value selection
            assign DEFAULT_cnt_next_a0[7:0] = (W == 1) ? DEFAULT_cnt_next_w_eq_1_a0 :
                             (W == 4) ? DEFAULT_cnt_next_w_eq_4_a0 :
                                       8'h00; // default case
   
            // Parameter-dependent counter next value logic (kept in \SV_plus for synthesis)
            /*SV_plus*/
               generate
                  if (W == 1) begin : gen_cnt_w_eq_1
                     assign DEFAULT_cnt_next_w_eq_1_a0[7:0] = {DEFAULT_op_b_a0, DEFAULT_data_hi_a0[7], DEFAULT_data_hi_a0[5:0]-6'd1};
                  end
                  if (W == 4) begin : gen_cnt_w_eq_4
                     assign DEFAULT_cnt_next_w_eq_4_a0[7:0] = {DEFAULT_op_b_a0[3:2], DEFAULT_data_hi_a0[5:0]-6'd4};
                  end
               endgenerate
   
            // === SEQUENTIAL LOGIC ===
   
            // High byte register: handles load, shift, and counter operations
            assign DEFAULT_data_hi_n1[7:0] = (DEFAULT_shift_en_a0 | DEFAULT_cnt_en_a0 | DEFAULT_load_a0) ?
                               (DEFAULT_load_a0 ? DEFAULT_dat_a0[31:24] : DEFAULT_dat_shamt_a0 & {2'b11, !(DEFAULT_shift_op_a0 & DEFAULT_cnt7_a0 & !DEFAULT_cnt_en_a0), 5'b11111}) :
                               DEFAULT_data_hi_a0;
   
            // Low 24-bit register: handles load and shift operations
            assign DEFAULT_data_lo_n1[23:0] = (DEFAULT_shift_en_a0 | DEFAULT_load_a0) ?
                                (DEFAULT_load_a0 ? DEFAULT_dat_a0[23:0] : {DEFAULT_data_hi_a0[B:0], DEFAULT_data_lo_a0[23:W]}) :
                                DEFAULT_data_lo_a0;
   
            // === OUTPUT COMPUTATION ===
   
            assign DEFAULT_o_sh_done_a0 = DEFAULT_dat_shamt_a0[5];
            assign DEFAULT_o_op_b_a0[B:0] = DEFAULT_op_b_a0;
            assign DEFAULT_o_q_a0[B:0] = ({W{(DEFAULT_lsb_a0 == 2'd3)}} & DEFAULT_dat_combined_a0[W+23:24]) |
                        ({W{(DEFAULT_lsb_a0 == 2'd2)}} & DEFAULT_dat_combined_a0[W+15:16]) |
                        ({W{(DEFAULT_lsb_a0 == 2'd1)}} & DEFAULT_dat_combined_a0[W+7:8])   |
                        ({W{(DEFAULT_lsb_a0 == 2'd0)}} & DEFAULT_dat_combined_a0[W-1:0]);
            assign DEFAULT_o_dat_a0[31:0] = DEFAULT_dat_combined_a0;
   //_\end_source

   // Connect Verilog outputs:
   //_|default
      //_@0
         assign o_sh_done = DEFAULT_o_sh_done_a0;
         assign o_op_b = DEFAULT_o_op_b_a0;
         assign o_q = DEFAULT_o_q_a0;
         assign o_dat = DEFAULT_o_dat_a0;
//_\SV
endmodule


// Undefine macros defined by SandPiper.
`undef BOGUS_USE
