//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro
//_\source wip.tlv 64

//_\SV
`default_nettype none
module serv_ctrl
  #(parameter RESET_STRATEGY = "MINI",
    parameter RESET_PC = 32'd0,
    parameter WITH_CSR = 1,
    parameter W = 1,
    parameter B = W-1
  )
  (
   input wire 	     clk,
   input wire 	     i_rst,
   //State
   input wire 	     i_pc_en,
   input wire 	     i_cnt12to31,
   input wire 	     i_cnt0,
   input wire        i_cnt1,
   input wire 	     i_cnt2,
   //Control
   input wire 	     i_jump,
   input wire 	     i_jal_or_jalr,
   input wire 	     i_utype,
   input wire 	     i_pc_rel,
   input wire 	     i_trap,
   input wire        i_iscomp,
   //Data
   input wire [B:0] i_imm,
   input wire [B:0] i_buf,
   input wire [B:0] i_csr_pc,
   output wire [B:0] o_rd,
   output wire [B:0] o_bad_pc,
   //External
   output reg [31:0] o_ibus_adr);
// ---------- Generated Code Inlined Here (before 1st \TLV) ----------
// Generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro from Redwood EDA, LLC.
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)





//
// Signals declared top-level.
//

// For |default$i_buf.
logic [B:0] DEFAULT_i_buf_a0;

// For |default$i_cnt0.
logic DEFAULT_i_cnt0_a0;

// For |default$i_cnt1.
logic DEFAULT_i_cnt1_a0;

// For |default$i_cnt12to31.
logic DEFAULT_i_cnt12to31_a0;

// For |default$i_cnt2.
logic DEFAULT_i_cnt2_a0;

// For |default$i_csr_pc.
logic [B:0] DEFAULT_i_csr_pc_a0;

// For |default$i_imm.
logic [B:0] DEFAULT_i_imm_a0;

// For |default$i_iscomp.
logic DEFAULT_i_iscomp_a0;

// For |default$i_jal_or_jalr.
logic DEFAULT_i_jal_or_jalr_a0;

// For |default$i_jump.
logic DEFAULT_i_jump_a0;

// For |default$i_pc_en.
logic DEFAULT_i_pc_en_a0;

// For |default$i_pc_rel.
logic DEFAULT_i_pc_rel_a0;

// For |default$i_rst.
logic DEFAULT_i_rst_a0;

// For |default$i_trap.
logic DEFAULT_i_trap_a0;

// For |default$i_utype.
logic DEFAULT_i_utype_a0;

// For |default$new_pc.
logic [B:0] DEFAULT_new_pc_a0;

// For |default$o_bad_pc_output.
logic [B:0] DEFAULT_o_bad_pc_output_a0;

// For |default$o_ibus_adr_input.
logic [31:0] DEFAULT_o_ibus_adr_input_a0;

// For |default$o_ibus_adr_next.
logic [31:0] DEFAULT_o_ibus_adr_next_a0,
             DEFAULT_o_ibus_adr_next_a1;

// For |default$o_rd_output.
logic [B:0] DEFAULT_o_rd_output_a0;

// For |default$offset_aa.
logic [B:0] DEFAULT_offset_aa_a0;

// For |default$offset_bb.
logic [B:0] DEFAULT_offset_bb_a0;

// For |default$pc_plus_4.
logic [B:0] DEFAULT_pc_plus_4_a0;

// For |default$pc_plus_4_carry.
logic DEFAULT_pc_plus_4_carry_a0;

// For |default$pc_plus_4_carry_reg.
logic DEFAULT_pc_plus_4_carry_reg_n1,
      DEFAULT_pc_plus_4_carry_reg_a0;

// For |default$pc_plus_4_carry_reg_wire.
logic DEFAULT_pc_plus_4_carry_reg_wire_a0;

// For |default$pc_plus_offset.
logic [B:0] DEFAULT_pc_plus_offset_a0;

// For |default$pc_plus_offset_aligned.
logic [B:0] DEFAULT_pc_plus_offset_aligned_a0;

// For |default$pc_plus_offset_carry.
logic DEFAULT_pc_plus_offset_carry_a0;

// For |default$pc_plus_offset_carry_reg.
logic DEFAULT_pc_plus_offset_carry_reg_n1,
      DEFAULT_pc_plus_offset_carry_reg_a0;

// For |default$pc_plus_offset_carry_reg_wire.
logic DEFAULT_pc_plus_offset_carry_reg_wire_a0;

// For |default$plus_4.
logic [B:0] DEFAULT_plus_4_a0;

// For |default$program_counter.
logic [B:0] DEFAULT_program_counter_a0;

// For |default$reset.
logic DEFAULT_reset_a0;




   //
   // Scope: |default
   //

      // Staging of $o_ibus_adr_next.
      always_ff @(posedge clk) DEFAULT_o_ibus_adr_next_a1[31:0] <= DEFAULT_o_ibus_adr_next_a0[31:0];

      // Staging of $pc_plus_4_carry_reg.
      always_ff @(posedge clk) DEFAULT_pc_plus_4_carry_reg_a0 <= DEFAULT_pc_plus_4_carry_reg_n1;

      // Staging of $pc_plus_offset_carry_reg.
      always_ff @(posedge clk) DEFAULT_pc_plus_offset_carry_reg_a0 <= DEFAULT_pc_plus_offset_carry_reg_n1;



// ---------- Generated Code Ends ----------
//_\TLV
   // Connect Verilog inputs to pipesignals
   //_|default
      //_@0
         assign DEFAULT_i_rst_a0 = i_rst;
         assign DEFAULT_i_pc_en_a0 = i_pc_en;
         assign DEFAULT_i_cnt12to31_a0 = i_cnt12to31;
         assign DEFAULT_i_cnt0_a0 = i_cnt0;
         assign DEFAULT_i_cnt1_a0 = i_cnt1;
         assign DEFAULT_i_cnt2_a0 = i_cnt2;
         assign DEFAULT_i_jump_a0 = i_jump;
         assign DEFAULT_i_jal_or_jalr_a0 = i_jal_or_jalr;
         assign DEFAULT_i_utype_a0 = i_utype;
         assign DEFAULT_i_pc_rel_a0 = i_pc_rel;
         assign DEFAULT_i_trap_a0 = i_trap;
         assign DEFAULT_i_iscomp_a0 = i_iscomp;
         assign DEFAULT_i_imm_a0[B:0] = i_imm;
         assign DEFAULT_i_buf_a0[B:0] = i_buf;
         assign DEFAULT_i_csr_pc_a0[B:0] = i_csr_pc;
         assign DEFAULT_o_ibus_adr_input_a0[31:0] = o_ibus_adr;  // Read current value for program_counter

   // Instantiate the core logic macro
   //_\source wip.tlv 7   // Instantiated from wip.tlv, 121 as: m5+serv_ctrl_logic(/top)
      //_|default
         //_@0
            // Program counter increment logic
            // If i_iscomp=1: increment program_counter by 2 else increment program_counter by 4
            assign DEFAULT_plus_4_a0[B:0] = (W == 1) ? (DEFAULT_i_iscomp_a0 ? DEFAULT_i_cnt1_a0 : DEFAULT_i_cnt2_a0) : (W == 4) ? ((DEFAULT_i_cnt0_a0 | DEFAULT_i_cnt1_a0) ? (DEFAULT_i_iscomp_a0 ? 2 : 4) : 0) : 0;
   
            // Current program counter value
            assign DEFAULT_program_counter_a0[B:0] = DEFAULT_o_ibus_adr_input_a0[B : 0];
   
            // TL-Verilog standard reset signal
            assign DEFAULT_reset_a0 = DEFAULT_i_rst_a0;
   
            // Compute PC + 4 (or PC + 2 for compressed instructions)
            assign {DEFAULT_pc_plus_4_carry_a0, DEFAULT_pc_plus_4_a0[B:0]} = DEFAULT_program_counter_a0 + DEFAULT_plus_4_a0 + DEFAULT_pc_plus_4_carry_reg_wire_a0;
   
            // Next PC value selection logic
            // Priority: trap -> jump -> sequential (PC+4/PC+2)
            assign DEFAULT_new_pc_a0[B:0] = (| WITH_CSR) ?
                              ((W == 1) ? (DEFAULT_i_trap_a0 ? (DEFAULT_i_csr_pc_a0 & ! (DEFAULT_i_cnt0_a0 || DEFAULT_i_cnt1_a0)) : DEFAULT_i_jump_a0 ? DEFAULT_pc_plus_offset_aligned_a0 : DEFAULT_pc_plus_4_a0) :
                               (W == 4) ? (DEFAULT_i_trap_a0 ? (DEFAULT_i_csr_pc_a0 & ((DEFAULT_i_cnt0_a0 || DEFAULT_i_cnt1_a0) ? 4'b1100 : 4'b1111)) : DEFAULT_i_jump_a0 ? DEFAULT_pc_plus_offset_aligned_a0 : DEFAULT_pc_plus_4_a0) :
                               (DEFAULT_i_jump_a0 ? DEFAULT_pc_plus_offset_aligned_a0 : DEFAULT_pc_plus_4_a0)) :
                              (DEFAULT_i_jump_a0 ? DEFAULT_pc_plus_offset_aligned_a0 : DEFAULT_pc_plus_4_a0);
   
            // State register updates (non-blocking assignments converted to TLV)
            assign DEFAULT_pc_plus_4_carry_reg_n1 = DEFAULT_i_pc_en_a0 & DEFAULT_pc_plus_4_carry_a0;
            assign DEFAULT_pc_plus_offset_carry_reg_n1 = DEFAULT_i_pc_en_a0 & DEFAULT_pc_plus_offset_carry_a0;
   
            // Carry register wire connections for different word widths
            assign DEFAULT_pc_plus_offset_carry_reg_wire_a0 = (W > 1) ?
                                               {{B{1'b0}}, DEFAULT_pc_plus_offset_carry_reg_a0} :
                                               DEFAULT_pc_plus_offset_carry_reg_a0;
            assign DEFAULT_pc_plus_4_carry_reg_wire_a0 = (W > 1) ?
                                          {{B{1'b0}}, DEFAULT_pc_plus_4_carry_reg_a0} :
                                          DEFAULT_pc_plus_4_carry_reg_a0;
   
            // Jump/branch target calculation
            assign DEFAULT_offset_aa_a0[B:0] = {W{DEFAULT_i_pc_rel_a0}} & DEFAULT_program_counter_a0;  // PC-relative base
            assign DEFAULT_offset_bb_a0[B:0] = DEFAULT_i_utype_a0 ? (DEFAULT_i_imm_a0 & {W{DEFAULT_i_cnt12to31_a0}}) : DEFAULT_i_buf_a0;  // Offset value
            assign {DEFAULT_pc_plus_offset_carry_a0, DEFAULT_pc_plus_offset_a0[B:0]} = DEFAULT_offset_aa_a0 + DEFAULT_offset_bb_a0 + DEFAULT_pc_plus_offset_carry_reg_wire_a0;
   
            // Align jump target to word boundary (clear LSB for cnt0)
            assign DEFAULT_pc_plus_offset_aligned_a0[B:0] = (W > 1) ?
                                             {DEFAULT_pc_plus_offset_a0[B : 1], DEFAULT_pc_plus_offset_a0[0] & ! DEFAULT_i_cnt0_a0} :
                                             (DEFAULT_pc_plus_offset_a0[0] & ! DEFAULT_i_cnt0_a0);
   
            // Output signal generation
            assign DEFAULT_o_rd_output_a0[B:0] = ({W{DEFAULT_i_utype_a0}} & DEFAULT_pc_plus_offset_aligned_a0) | (DEFAULT_pc_plus_4_a0 & {W{DEFAULT_i_jal_or_jalr_a0}});  // Return address for JAL/JALR
            assign DEFAULT_o_bad_pc_output_a0[B:0] = DEFAULT_pc_plus_offset_aligned_a0;  // PC for exception handling
   
            // Compute the next o_ibus_adr value using pipesignals for cleaner logic
            assign DEFAULT_o_ibus_adr_next_a0[31:0] =
                 ((RESET_STRATEGY != "NONE") && DEFAULT_reset_a0)
                    ? RESET_PC :
                 DEFAULT_i_pc_en_a0
                    ? {DEFAULT_new_pc_a0, DEFAULT_o_ibus_adr_input_a0[31 : W]} :
                 //default
                      DEFAULT_o_ibus_adr_input_a0;
   //_\end_source

   // Connect TLV pipesignals to Verilog outputs
   //_|default
      //_@0
         assign o_rd = DEFAULT_o_rd_output_a0;
         assign o_bad_pc = DEFAULT_o_bad_pc_output_a0;
         assign o_ibus_adr = DEFAULT_o_ibus_adr_next_a1;

         /*SV_plus*/
            initial if (RESET_STRATEGY == "NONE") o_ibus_adr = RESET_PC;
//_\SV
endmodule


// Undefine macros defined by SandPiper.
`undef BOGUS_USE
