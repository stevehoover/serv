//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro
//_\source wip.tlv 53

//_\SV
module serv_bufreg #(
      parameter [0:0] MDU = 0,
      parameter W = 1,
      parameter B = W-1
)(
   input wire 	      i_clk,
   //State
   input wire 	      i_cnt0,
   input wire 	      i_cnt1,
   input wire 	      i_cnt_done,
   input wire 	      i_en,
   input wire 	      i_init,
   input wire           i_mdu_op,
   output wire [1:0]    o_lsb,
   //Control
   input wire 	      i_rs1_en,
   input wire 	      i_imm_en,
   input wire 	      i_clr_lsb,
   input wire 	      i_shift_op,
   input wire 	      i_right_shift_op,
   input wire [2:0]   i_shamt,
   input wire 	      i_sh_signed,
   //Data
   input wire [B:0] i_rs1,
   input wire [B:0] i_imm,
   output wire [B:0] o_q,
   //External
   output wire [31:0] o_dbus_adr,
   //Extension
   output wire [31:0] o_ext_rs1);

   // Clock assignment for TL-Verilog
   wire clk;
   assign clk = i_clk;
// ---------- Generated Code Inlined Here (before 1st \TLV) ----------
// Generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro from Redwood EDA, LLC.
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)





//
// Signals declared top-level.
//

// For |default$cc.
logic DEFAULT_cc_a0;

// For |default$cc_r.
logic [B:0] DEFAULT_cc_r_n1,
            DEFAULT_cc_r_a0;

// For |default$clr_lsb.
logic [B:0] DEFAULT_clr_lsb_a0;

// For |default$data.
logic [31:0] DEFAULT_data_n1,
             DEFAULT_data_a0;

// For |default$data_shift_update.
logic [31:0] DEFAULT_data_shift_update_a0;

// For |default$data_tail.
logic [W-2:0] DEFAULT_data_tail_n1,
              DEFAULT_data_tail_a0;

// For |default$i_clr_lsb.
logic DEFAULT_i_clr_lsb_a0;

// For |default$i_cnt0.
logic DEFAULT_i_cnt0_a0;

// For |default$i_cnt1.
logic DEFAULT_i_cnt1_a0;

// For |default$i_cnt_done.
logic DEFAULT_i_cnt_done_a0;

// For |default$i_en.
logic DEFAULT_i_en_a0;

// For |default$i_imm.
logic [B:0] DEFAULT_i_imm_a0;

// For |default$i_imm_en.
logic DEFAULT_i_imm_en_a0;

// For |default$i_init.
logic DEFAULT_i_init_a0;

// For |default$i_mdu_op.
logic DEFAULT_i_mdu_op_a0;

// For |default$i_right_shift_op.
logic DEFAULT_i_right_shift_op_a0;

// For |default$i_rs1.
logic [B:0] DEFAULT_i_rs1_a0;

// For |default$i_rs1_en.
logic DEFAULT_i_rs1_en_a0;

// For |default$i_sh_signed.
logic DEFAULT_i_sh_signed_a0;

// For |default$i_shamt.
logic [2:0] DEFAULT_i_shamt_a0;

// For |default$i_shift_op.
logic DEFAULT_i_shift_op_a0;

// For |default$lsb.
logic [1:0] DEFAULT_lsb_n1,
            DEFAULT_lsb_a0;

// For |default$lsb_w_eq_1.
logic [1:0] DEFAULT_lsb_w_eq_1_a0;

// For |default$muxdata.
logic [2 * W + B - 2:0] DEFAULT_muxdata_a0;

// For |default$muxout.
logic [B:0] DEFAULT_muxout_a0;

// For |default$o_dbus_adr.
logic [31:0] DEFAULT_o_dbus_adr_a0;

// For |default$o_ext_rs1.
logic [31:0] DEFAULT_o_ext_rs1_a0;

// For |default$o_lsb.
logic [1:0] DEFAULT_o_lsb_a0;

// For |default$o_q.
logic [B:0] DEFAULT_o_q_a0;

// For |default$qq.
logic [B:0] DEFAULT_qq_a0;

// For |default$qq_w_eq_1.
logic [B:0] DEFAULT_qq_w_eq_1_a0;

// For |default$qq_w_eq_4.
logic [B:0] DEFAULT_qq_w_eq_4_a0;

// For |default$shift_amount.
logic [2:0] DEFAULT_shift_amount_a0;




   //
   // Scope: |default
   //

      // Staging of $cc_r.
      always_ff @(posedge clk) DEFAULT_cc_r_a0[B:0] <= DEFAULT_cc_r_n1[B:0];

      // Staging of $data.
      always_ff @(posedge clk) DEFAULT_data_a0[31:0] <= DEFAULT_data_n1[31:0];

      // Staging of $data_tail.
      always_ff @(posedge clk) DEFAULT_data_tail_a0[W-2:0] <= DEFAULT_data_tail_n1[W-2:0];

      // Staging of $lsb.
      always_ff @(posedge clk) DEFAULT_lsb_a0[1:0] <= DEFAULT_lsb_n1[1:0];



// ---------- Generated Code Ends ----------
//_\TLV
   // Connect Verilog inputs to pipesignals
   //_|default
      //_@0
         assign DEFAULT_i_en_a0 = i_en;
         assign DEFAULT_i_cnt0_a0 = i_cnt0;
         assign DEFAULT_i_cnt1_a0 = i_cnt1;
         assign DEFAULT_i_cnt_done_a0 = i_cnt_done;
         assign DEFAULT_i_init_a0 = i_init;
         assign DEFAULT_i_mdu_op_a0 = i_mdu_op;
         assign DEFAULT_i_rs1_en_a0 = i_rs1_en;
         assign DEFAULT_i_imm_en_a0 = i_imm_en;
         assign DEFAULT_i_clr_lsb_a0 = i_clr_lsb;
         assign DEFAULT_i_shift_op_a0 = i_shift_op;
         assign DEFAULT_i_right_shift_op_a0 = i_right_shift_op;
         assign DEFAULT_i_shamt_a0[2:0] = i_shamt;
         assign DEFAULT_i_sh_signed_a0 = i_sh_signed;
         assign DEFAULT_i_rs1_a0[B:0] = i_rs1;
         assign DEFAULT_i_imm_a0[B:0] = i_imm;

   // Instantiate the serv_bufreg macro
   //_\source wip.tlv 6   // Instantiated from wip.tlv, 111 as: m5+serv_bufreg(/top)
      //_|default
         //_@0
            // === COMPUTATION STAGE ===
            // Clear LSB mask: clear bit 0 when count is at 0 and clear is requested
            // For widths > 1, upper bits remain zero
            assign DEFAULT_clr_lsb_a0[B:0] = (B > 0) ? {{B{1'b0}}, (DEFAULT_i_cnt0_a0 & DEFAULT_i_clr_lsb_a0)} : (DEFAULT_i_cnt0_a0 & DEFAULT_i_clr_lsb_a0);
   
            // Buffer register adder: combines rs1 input, immediate input, and carry
            assign {DEFAULT_cc_a0, DEFAULT_qq_a0[B:0]} = {1'b0, (DEFAULT_i_rs1_a0 & {W{DEFAULT_i_rs1_en_a0}})} + {1'b0, (DEFAULT_i_imm_a0 & {W{DEFAULT_i_imm_en_a0}} & ~ DEFAULT_clr_lsb_a0)} + DEFAULT_cc_r_a0;
   
            // Shift amount computation for W==4 case
            assign DEFAULT_shift_amount_a0[2:0] = ! DEFAULT_i_shift_op_a0 ? 3'd3 :
                                 DEFAULT_i_right_shift_op_a0 ? (3'd3 + {1'b0, DEFAULT_i_shamt_a0[1 : 0]}) :
                                 ({1'b0, ~ DEFAULT_i_shamt_a0[1 : 0]});
   
            // Mux data preparation and selection for W==4 case
            assign DEFAULT_muxdata_a0[2 * W + B - 2:0] = {DEFAULT_data_a0[W + B - 1 : 0], DEFAULT_data_tail_a0};
            assign DEFAULT_muxout_a0[B:0] = DEFAULT_muxdata_a0[({1'b0, DEFAULT_shift_amount_a0}) +: W];
   
            // Output computation for different width cases
            assign DEFAULT_lsb_w_eq_1_a0[1:0] = DEFAULT_data_a0[1 : 0];
            assign DEFAULT_qq_w_eq_1_a0[B:0] = {W{DEFAULT_data_a0[0]}} & {W{DEFAULT_i_en_a0}};
            assign DEFAULT_qq_w_eq_4_a0[B:0] = DEFAULT_i_en_a0 ? DEFAULT_muxout_a0 : {W{1'b0}};
   
            // Final output selection based on module parameters
            assign DEFAULT_o_lsb_a0[1:0] = (MDU & DEFAULT_i_mdu_op_a0) ? 2'b00 :
                          (W == 1) ? DEFAULT_lsb_w_eq_1_a0 : DEFAULT_lsb_a0;
            assign DEFAULT_o_q_a0[B:0] = (W == 1) ? DEFAULT_qq_w_eq_1_a0 : DEFAULT_qq_w_eq_4_a0;
            assign DEFAULT_o_dbus_adr_a0[31:0] = {DEFAULT_data_a0[31 : 2], 2'b00};
            assign DEFAULT_o_ext_rs1_a0[31:0] = DEFAULT_data_a0;
   
            // === SEQUENTIAL UPDATE STAGE ===
            // State updates for next cycle (using <<1 for register behavior)
            // Update LSB when enabled and at count 0
            assign DEFAULT_lsb_n1[1:0] = (DEFAULT_i_en_a0 && DEFAULT_i_cnt0_a0) ? DEFAULT_qq_a0[1 : 0] : DEFAULT_lsb_a0;
            // Update data tail, masking out completed bits
            assign DEFAULT_data_tail_n1[W-2:0] = DEFAULT_i_en_a0 ? (DEFAULT_data_a0[B : 1] & {B{~ DEFAULT_i_cnt_done_a0}}) : DEFAULT_data_tail_a0;
            // Carry register: clear to zero, but preserve carry bit when enabled
            assign DEFAULT_cc_r_n1[B:0] = {{B{1'b0}}, DEFAULT_cc_a0 & DEFAULT_i_en_a0};
   
            // Common subexpression for data register update
            assign DEFAULT_data_shift_update_a0[31:0] = DEFAULT_i_en_a0 ? {DEFAULT_i_init_a0 ? DEFAULT_qq_a0 : {W{DEFAULT_data_a0[31] & DEFAULT_i_sh_signed_a0}}, DEFAULT_data_a0[31 : W]} : DEFAULT_data_a0;
   
            assign DEFAULT_data_n1[31:0] = (W == 1) ?
                             {DEFAULT_data_shift_update_a0[31 : 2],
                              ((DEFAULT_i_init_a0 ? (DEFAULT_i_cnt0_a0 | DEFAULT_i_cnt1_a0) : DEFAULT_i_en_a0) ? {DEFAULT_i_init_a0 ? DEFAULT_qq_a0 : DEFAULT_data_a0[2], DEFAULT_data_a0[1]} : DEFAULT_data_a0[1 : 0])} :
                             DEFAULT_data_shift_update_a0;
   //_\end_source

   // Connect pipesignals to Verilog outputs
   //_|default
      //_@0
         assign o_lsb = DEFAULT_o_lsb_a0;
         assign o_q = DEFAULT_o_q_a0;
         assign o_dbus_adr = DEFAULT_o_dbus_adr_a0;
         assign o_ext_rs1 = DEFAULT_o_ext_rs1_a0;


//_\SV
endmodule


// Undefine macros defined by SandPiper.
`undef BOGUS_USE
